

##  java 内存模型

java 内存模型是围绕 **原子性**（**基本类型除了long和double以外的读写访问时具有原子性**。注意：这里指的原子性是每个基本类型的读写操作，不是CAS操作。另外布尔值在虚拟机中被认为是 int 类型，如果是布尔数组则每个布尔位占 8 bit。所以布尔值的读写操作也是原子性的）、**可见性**（一个线程修改了共享变量的值，另一个线程必须立即发现这个修改）、**有序性**（如果在本线程内观察，所有的操作都是有序的。如果在另外一个线程中观察，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句表现为”指令重排和工作内存与主内存同步延迟现象“）这三个特征来建立的。

java 内存模型规定所有变量（线程私有的方法参数和局部变量除外）都存储在主存内，每条线程还有自己的工作内存，线程的工作内存中保存着该线程使用的变量在主存中的副本拷贝，线程对变量的所有操作必须在工作内存中进行，而不能直接读取主存中的变量。不同的线程之间也无法直接获取对方工作内存中的变量，线程间变量值的传递均要通过主内存来完成。

### varHandle 类中的解释

访问模式控制原子性和一致性属性。 *普通的* read（`get`）和write（`set`）访问保证仅对于引用和最多32位的原始值是按位原子的，并且对于除执行线程之外的线程没有强加可观察的排序约束。对于访问同一变量，*不透明*操作是按位原子和相干有序的。除了遵守不透明属性之外，在匹配*释放*模式写入及其先前的访问之后，还会对*获取*模式读取及其后续访问进行排序 。除了服从Acquire和Release属性外，所有 *Volatile* 操作完全相互排序。

## volatile

volatile 的两个特性：

1. 保证 volatile 修饰的变量对所有线程的可见性（当一条线程修改了变量的值，对于其他线程来说是立即可见的）。但是不保证安全性对于long和double有非原子性协定，并不能保证其修改操作是原子性的。

2. 禁止指令重排。

   原理：将代码生成汇编代码，有volatile修饰的变量，赋值后多执行了一个 `lock addl $0x0`操作，这个操作相当于一个内存屏障（Memory Barrier 或 Menory Dence，指令重排时不能把后面的指令重排到内存屏障之前的位置），当lock指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了指令重排序无法越过内存屏障的效果。

## Synchronized

原理：

通过monitorenter 与 monitorexit 两个字节码指令，修饰在Synchronized前后。这两个字节码都需要一个reference 类型的参数来证明要指定和解锁的对象。如果 java 程序中的synchronized明确指定了对象参数（synchronized 代码块），那么这个对象就是reference；如果没有明确指定，那就根据synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或Class 对象来作为锁对象。

在执行monitorenter指令的时候，首先尝试获取对象的锁。如果这个对象没有锁定，或者当前线程已经拥有了那个对象的锁，就把锁的计数器 +1，相应的在执行monitorexit 的时候，会将计数器减 1，当计数器为 0 的时候，锁就被释放。如果获取对象失败，那么线程就需要阻塞等待，直到对象锁被另外一个线程释放为止。

注意：synchronized 同步块对于同一个线程来说是可以重入的，不会把自己锁死。并且，java的线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要很多处理器的时间。所以synchronized 同步块是一个相对来说重量级的操作。但是虚拟机对该关键字的使用会进行一些优化。使得其性能有提高，在并发集合中也会使用synchronized同步块，进行同步操作。

### 悲观锁和乐观锁

​    一：悲观锁

​      悲观锁，就是不管是否发生多线程冲突，只要存在这种可能，就每次访问都加锁，加锁就会导致锁之间的争夺，有争夺就会有输赢，输者等待。

​      syncrhoized是一种独占锁，即：占用该锁的线程才可以执行，申请该锁的线程就只能挂起等待，直到占用锁的线程释放锁才唤醒，拿到锁并执行。由于在进程挂起和恢复执行过程中存在着很大的开销，并且当一个线程正在等待锁时，它不能做任何事。所以syncrhoized是一种悲观锁，凡是用syncrhoized加了锁的多线程之间都会因锁的争夺结果导致挂起、唤醒等开销。

 

​    二：乐观锁

​      获得锁后一直持有锁以防本线程再次申请该锁造成无谓的解锁再加锁开销，或者假设没有冲突而去完成同步代码块如果冲突再循环重试，或者采取申请锁失败后不立刻挂起而是稍微等待再次尝试获取 等待策略，以减少线程因为挂起、阻塞、唤醒（发生CPU的调度切换） 而造成的开销。

​      偏向锁、轻量级锁（CAS轮询）、自旋锁 就是基于上述思路的乐观锁。

​      在多线程的加锁机制中，JVM会首先尝试乐观锁，失败后才调用悲观锁。

## 锁优化：

#### 自旋锁与适应自旋：

为了减少线程挂起和恢复所耗费的机器处理时间，可以让线程在请求锁之前进行一个循环（自旋），而不放弃处理器时间，看看持有锁的线程是否很快就会释放锁。这项技术就是自旋锁。

在 JDK 1.6中，引入了自适应性自旋锁，使自旋时间不在固定，而是由前一次在同一个锁上的自旋时间和持有锁的线程状态来决定。如果自旋等待刚刚成功获取锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续更长的时间。如果一个线程很少获取到锁，那么也有可能取消自旋的过程，避免浪费处理机资源。

#### 锁消除：

锁消除是指虚拟机**即时编译器**在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去而被其他线程访问到，那就可以把它们当做栈上数据对待。认为他们是线程私有的，同步加锁自然就无须进行。

#### 锁粗化：

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中进行同步，这样是为了使得需要同步的操作数尽量可能变小，如果存在竞争，那等待锁的线程也能尽快拿到锁。

但是，如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁、解锁的操作是出现在循环体中的，那即使没有线程竞争，频繁地同步操作也会造成不必要的性能损耗。

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列外部。这样只需要一次加锁操作就可以了。

#### 轻量级锁：

轻量级锁是 JDK 1.6 中新加入的锁机制，它名字中的“轻量级” 是相对于使用操作系统的互斥量来实现的传统锁而言的，因此传统的锁机制就成为“重量级锁”。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

理解轻量级锁，必须先了解（HorSpot）虚拟机的对象（对象头）的内存布局。HotSpot 虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64比特，官方称它为“Mark Word”，他是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数据对象的话，还会有一个额外的部分由于存储数组长度。

对象头信息时与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word 的32 bit 空间中的 25 bit 用于存储对象的哈希吗，4 bit用于存储对象分代年龄，2 bit用于存储锁标志位， 1 bit 固定为 0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向） 下对象头的锁标志位内容为：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级记录的指针                 | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC标记             |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为**锁记录**（Lock Record）的空间，用于存储对象目前的Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced前缀，即 **Displaced Mark Word**）。

然后，虚拟机将使用CAS操作尝试将对象的 Mark Word 更新为指向Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2 bit）将转变为“00”，即表示此对象处于轻量级锁定的状态。

如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不在有效，要膨胀为重量级锁，锁标志的状态变为“10”，Mark Word 中存储的就是指向重量级锁互斥量的指针，后面等待的线程也要进入阻塞状态。

上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作来进行的，如果对象的 Mark Word 仍然指向这线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程栈帧中复制的 Displaced Mark Word 替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试或获取该锁（锁标志位的变化），那就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有了竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

#### 偏向锁:

偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无争用情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无争用的情况下把整个同步都消除掉，连CAS操作都不做了。

偏向锁会偏向于第一个获得他的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。**同时使用CAS操作把获取到这个锁的线程 ID 记录在 Mark Word之中**，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块中时，虚拟机都可以不再进行任何同步操作。

当有另外一个线程取尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向，后恢复到未锁定（状态标志为“01”）或轻量级锁定（状态标志为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。

偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。可以使用参数`-XX:-UseBiaswdLocking`来禁止偏向锁优化。