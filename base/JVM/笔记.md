## 12.4。类和接口的初始化

类的*初始化*包括执行其静态初始化程序和`static`类中声明的字段（类变量）的初始化程序。

*初始化* 的接口由执行用于字段（常数）的初始化的接口中声明。

### 12.4.1。发生初始化时

类或接口类型T将在第一次出现以下任何一个之前立即初始化：

- T是一个类，并且创建了T的实例。
- 阿`static`通过声明的方法Ť被调用。
- 阿`static`通过声明字段Ť被分配。
- 使用`static`由T声明的字段，该字段不是常量变量（第[4.12.4节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4)）。

初始化类时，初始化其超类（如果它们之前未初始化），以及声明任何默认方法（第[9.4.3节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）的任何超接口（第[8.1.5 ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.5)[节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）（如果它们之前未初始化） ）。接口的初始化本身不会导致其任何超接口的初始化。

对`static`字段的引用（第[8.3.1.1节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1)）仅导致实际声明它的类或接口的初始化，即使它可能通过子类的名称，子接口或实现接口的类来引用。

在类`Class`和包中调用某些反射方法`java.lang.reflect`也会导致类或接口初始化。

在任何其他情况下，不会初始化类或接口。

请注意，编译器可能会 在接口中生成*合成*默认方法，即既未显式也未隐式声明的默认方法（第[13.1节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-13.html#jls-13.1)）。尽管源代码没有给出应该初始化接口的指示，但是这样的方法将触发接口的初始化。

目的是类或接口类型具有一组初始化器，使其处于一致状态，并且该状态是其他类观察到的第一个状态。静态初始值设定项和类变量初始值设定项以文本顺序执行，并且可能不引用在声明在使用后以文本方式出现的类中声明的类变量，即使这些类变量在范围内（第[8.3.3节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.3)）。此限制旨在在编译时检测大多数循环或其他格式错误的初始化。

初始化代码不受限制的事实允许构造示例，其中在其初始化表达式被评估之前，当它仍然具有其初始默认值时可以观察到类变量的值，但是这样的示例在实践中是罕见的。（这些示例也可以构造为例如变量初始化（第[12.5节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5)）。）这些初始化器中提供了Java编程语言的全部功能。程序员必须小心谨慎。这种能力给代码生成器带来了额外的负担，但是在任何情况下都会产生这种负担，因为Java编程语言是并发的（[§12.4.2](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4.2)).

## 自动内存管理机制

运行时数据区：Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时销毁。 其他数据区域是每个线程所占的空间。 线程数据区域是随着线程销毁和创建的。

**The `pc` Register**：Java虚拟机可以同时支持许多执行线程。 每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。 在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（第2.6节）。 如果该方法不是native方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。 如果线程当前正在执行的方法是native的，则Java虚拟机的pc寄存器的值是未定义的。 Java虚拟机的pc寄存器足够宽，可以在特定平台上保存returnAddress或native 指针。

 **Java Virtual Machine Stacks**：每个Java虚拟机线程都有一个私有Java虚拟机栈，与线程同时创建。 Java虚拟机栈存储帧。 Java虚拟机栈类似于传统语言的栈，例如C：它保**存局部变量和部分结果，并在方法调用和返回中起作用**。 由于除了压入和弹出帧之外，永远不会直接操作Java虚拟机栈，而帧可以是堆分配的。所以 Java虚拟机栈的内存不需要是连续的。

在Java®虚拟机规范的第一版中，Java虚拟机栈被和Java栈是一个意思。

此规范允许Java虚拟机栈具有固定大小或根据计算的需要动态扩展和收缩。 如果Java虚拟机堆栈具有固定大小，则可以在创建该栈时独立选择每个Java虚拟机堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，控制最大和最小大小。

以下异常条件与Java虚拟机堆栈相关联：

- 如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机会抛出`StackOverflowError`.
- 如果可以动态扩展Java虚拟机堆栈，并且尝试进行扩展但可以使用的内存不足以实现扩展，或者可以使用的内存不足以为新线程创建初始Java虚拟机堆栈，则可以使用Java虚拟机抛出`OutOfMemoryError`.

**Heap**：Java虚拟机有一个在所有Java虚拟机线程之间共享的堆。堆是运行时数据区，**从中分配所有类实例和数组的内存**。

堆是在虚拟机启动时创建的。存储在堆上的对象由自动存储管理系统（称为垃圾收集器）回收 ; 对象永远不会被用户显式释放。 Java虚拟机假设没有特定类型的自动存储管理系统，可以根据实现者的系统要求选择存储管理技术。堆可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的堆，则可以收缩。**堆的内存不需要是连续的。**

Java虚拟机实现可以为程序员或用户提供对堆的初始大小的控制，以及如果可以动态扩展或收缩堆，则控制最大和最小堆大小。

以下异常情况与堆相关联：

- 如果计算需要的堆的大小超过自动存储管理系统可用的堆，则Java虚拟机会抛出`OutOfMemoryError`。

**Method Area**：Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。 方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。 它存储每个类的结构，例如**运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括类和接口初始化以及实例初始化中使用的特殊方法**

方法区域是在虚拟机启动时创建的。 虽然方法区域在逻辑上是堆的一部分，但是简单的虚拟机实现可能选择不进行垃圾收集或压缩它。 此规范不强制方法区域的位置或用于管理编译代码的策略。 方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以缩小方法区域。 方法区域的内存不需要是连续的。

Java虚拟机实现可以为程序员或用户提供对方法区域的初始大小的控制，以及在变大小方法区域的情况下，控制最大和最小方法区域大小。

以下异常条件与方法区域相关联：

- 如果方法区域中的内存不能满足分配请求，则Java虚拟机会抛出`OutOfMemoryError`。



 **Run-Time Constant Pool**:运行时常量池在每个类或者接口的class文件中代表 `constant_pool`表。 **它包含几种常量，从编译时已知的字面量到必须在运行时解析的方法和字段引用**。 运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。

每个运行时常量池都是从Java虚拟机的方法区域分配的。 当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池。

以下异常条件与类或接口的运行时常量池的构造相关联：

- 创建类或接口时，如果运行时常量池的构造需要的内存比Java虚拟机的方法区域中可用的内存多，则Java虚拟机会抛出`OutOfMemoryError`。

**Native Method Stacks**：Java虚拟机的实现可以使用传统的堆栈，俗称“C堆栈”，以支持native方法（用Java编程语言以外的语言编写的方法）。 native方法堆栈也可以通过以诸如C语言的语言为Java虚拟机的指令集实现解释器来使用。无法加载native方法并且本身不依赖于传统堆栈的Java虚拟机实现不需要提供本机方法栈。 如果提供，则通常在创建每个线程时为每个线程分配native方法堆栈。

此规范允许本机方法堆栈具有固定大小或根据计算的需要动态扩展和收缩。 如果本机方法堆栈具有固定大小，则可以在创建该堆栈时独立地选择每个本机方法堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对本机方法堆栈的初始大小的控制，以及在不同大小的本机方法堆栈的情况下，控制最大和最小方法堆栈大小。

以下异常条件与本机方法堆栈相关联：

- 以下异常条件相关联如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机会抛出`StackOverflowError`。

- 如果可以动态扩展native方法堆栈并尝试native方法栈扩展但可用内存不足，或者如果可用内存不足以为新线程创建初始本机方法堆栈，则Java虚拟机会抛出`OutOfMemoryError `。

------



## Frames

栈帧用于存储数据和部分结果，以及执行动态链接，返回方法的值以及调度异常。

每次调用方法时都会创建一个新帧。 当方法调用完成时，无论是正常完成或者抛出异常（它会抛出未捕获的异常），栈帧都将被销毁。 帧是从创建帧的线程的Java虚拟机堆栈分配的。 每个帧都有自己的局部变量数组，自己的操作数堆栈，以及对当前方法所在类的运行时常量池的引用。

可以使用附加的特定于实现的信息来扩展帧，例如调试信息。

局部变量数组和操作数堆栈的大小在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。 因此，帧数据结构的大小仅取决于Java虚拟机的实现，并且可以在方法调用上同时分配这些结构的存储器。

只有一个帧（执行方法的帧）在给定控制线程中的任何点处都是活动的。 该帧被称为当前帧，并且其方法被称为当前方法。 定义当前方法的类是当前类。 局部变量和操作数堆栈的操作通常参考当前帧。

如果栈帧的方法调用另一个方法或其方法完成，则此栈帧将不再是当前栈帧。 调用方法时，会创建一个新帧，并在控制转移到新方法时成为当前帧。 在方法返回时，当前帧将其方法调用的结果（如果有）传递回前一帧。 然后当前一帧变为当前帧时丢弃当前帧。

请注意，由线程创建的帧是线程私有的，并且不能被任何其他线程引用。

**Local Variables**：每个帧包含一个称为局部变量的变量数组。 帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式提供，同时提供与帧相关的方法的代码。

单个局部变量可以包含boolean，byte，char，short，int，float，reference或returnAddress类型的值。 一对局部变量可以包含long或double类型的值。

通过索引来确定局部变量的位置。 第一个局部变量的索引为零。 索引的大小介于0和局部变量数组长度 - 1之间。

long类型或double类型的值占用两个连续的局部变量。 只能使用较小的索引来处理这样的值。 例如，存储在索引 n 的局部变量数组中的double类型实际上占用索引为n和n + 1的局部变量; 但是，索引n + 1的局部变量无法加载，它可以存储到。只能通过索引 n 获取。

Java虚拟机不要求n是偶数。 直观地说，long和double类型的值不需要在局部变量数组中进行64位对齐。 实现者可以使用为该值保留的两个局部变量自由决定表示此类值的适当方式。

Java虚拟机使用局部变量在方法调用上传递参数。 在类方法（static方法）调用中，任何参数都是从局部变量0开始的连续局部变量中传递的。在实例方法调用中，局部变量0总是用于传递对调用实例方法的对象的引用（在Java）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。

**Operand Stacks**：每个栈帧里包含一个后进先出（LIFO）堆栈，称为其操作数堆栈。 栈帧的操作数栈的最大深度在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。

在上下文清晰的地方，我们有时会将当前帧的操作数堆栈称为操作数堆栈。

当创建包含操作数栈的帧时，操作数堆栈为空。 Java虚拟机提供指令以将局部变量或字段中的常量或值加载到操作数堆栈上。 其他Java虚拟机指令从操作数堆栈获取操作数，对它们进行操作，并将结果推回操作数堆栈。 操作数堆栈还用于准备要传递给方法和接收方法结果的参数。

例如，`iadd`指令将两个int值一起添加。 它要求要添加的int值是操作数堆栈的前两个值，由前面的指令推送到那里。 两个int值都从操作数堆栈中弹出。 它们相加后的总和被推回到操作数堆栈上。 子计算可以嵌套在操作数堆栈上，从而产生可以由包含计算使用的值。

操作数堆栈上的每个条目都可以包含任何Java虚拟机类型的值，包括long类型或double类型的值。

必须以适合其类型的方式操作操作数堆栈中的值。 例如，不可能推送两个int值，然后将它们视为long或推送两个float值，然后使用`iadd`指令添加它们。 少量Java虚拟机指令（dup指令和交换）作为原始值在运行时数据区域上运行，而不考虑它们的特定类型; 这些指令的定义方式使它们不能用于修改或分解单个值。 操作数堆栈操作的这些限制是通过类文件验证强制执行的。

在任何时间点，操作数堆栈都具有相关联的深度，其中long或double类型的值对深度贡献两个单位，而任何其他类型的值贡献一个单位。

**Dynamic Linking**：每个栈帧包含对运行时常量池（Run-Time Constant Pool）的引用，用于支持对当前方法的类型的方法代码的动态链接的。

方法的 class 文件代码是指要调用的方法和要通过符号引用访问的变量。 动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移。

方法和变量的这种后期绑定使得方法使用的其他类中的更改不太可能破坏此代码。

**Normal Method Invocation Completion**：如果调用不会直接从Java虚拟机或执行显式throw语句引发异常，则方法调用会正常完成。 如果当前方法的调用正常完成，则可以将值返回给调用方法。 当被调用的方法执行其中一个返回指令时，就会发生这种情况，返回指令的选择必须适合于返回值的类型（如果有的话）。

在这种情况下，当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈，调用者的程序计数器适当地递增以跳过方法调用指令。 然后执行在调用方法的帧中正常继续，返回值（如果有）被推送到该帧的操作数堆栈。

 **Abrupt Method Invocation Completion**：如果在方法中执行Java虚拟机指令导致Java虚拟机抛出异常，并且该异常未在该方法中处理，则方法调用突然完成。 执行athrow指令还会导致显式抛出异常，如果当前方法未捕获异常，则会导致突然的方法调用完成。 突然完成的方法调用永远不会向其调用者返回值。

**Representation of Objects**：Java虚拟机不要求对象的任何特定内部结构。

在Oracle的一些Java虚拟机实现中，对类实例的引用是指向句柄的指针，该句柄本身是一对指针：一个指向包含对象方法的表和一个指向表示Class对象的指针 对象的类型，另一个是从堆中为对象数据分配的内存。



## 特殊方法

------

**实例初始化方法**：

类具有零个或多个实例初始化方法，每个方法通常对应于用Java编程语言编写的构造函数。

- 如果满足以下所有条件，则方法是实例初始化方法：
- 它在类（不是接口）中定义。
- 它具有特殊名称<init>。
- 它是`void` 返回类型

在类中，任何名为<init>的非void方法都不是实例初始化方法。 在接口中，任何名为<init>的方法都不是实例初始化方法。 任何Java虚拟机指令都不能调用此类方法，并且格式检查会拒绝这些方法。

实例初始化方法的声明和使用受Java虚拟机的约束。 对于声明，方法的 access_flags 项和代码数组受到约束。 对于使用，实例初始化方法可以仅由未初始化的类实例上的invokespecial指令调用。

因为名称<init>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

类初始化方法：类或接口最多只有一个类或接口初始化方法，并由调用该方法的Java虚拟机初始化。

如果满足以下所有条件，则方法是类或接口初始化方法：

- 它的特殊名称是<clinit>。
- 它是`void` 返回类型
- 在版本号为51.0或更高的类文件中，该方法设置了ACC_STATIC标志并且不带参数

在Java SE 7中引入了对 ACC_STATIC 的要求，并且在Java SE 9中没有引用参数。在版本号为50.0或更低的类文件中，名为<clinit>的void 方法被认为是类或接口初始化方法 无论其ACC_STATIC标志的设置或是否需要参数。

类文件中名为<clinit>的其他方法不是类或接口初始化方法。 它们永远不会被Java虚拟机本身调用，不能被任何Java虚拟机指令调用，并且会被格式检查拒绝。

因为名称<clinit>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

**签名多态方法**：如果满足以下所有条件，则方法是签名多态的：

- 它在java.lang.invoke.MethodHandle类或java.lang.invoke.VarHandle类中声明。
- 它有一个`Object [] `类型的形式参数。
- 它设置了ACC_VARARGS和ACC_NATIVE标志。



## 加载，链接和初始化

注意:以下由类加载器创建的都代表Class类。

------



Java虚拟机动态加载，链接和初始化类和接口。加载是查找具有特定名称的类或接口类型的二进制表示并从该二进制表示*创建*类或接口的过程。链接是获取类或接口并将其组合到Java虚拟机的运行时状态以便可以执行的过程。类或接口的初始化包括执行类或接口初始化方法`<clinit>`。

在本章中，第 [5.1节](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.1)描述了Java虚拟机如何从类或接口的二进制表示中派生符号引用。[§5.2](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2)解释了如何首先由Java虚拟机启动加载，链接和初始化的过程。[§5.3](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.3)指定类加载器如何加载类和接口的二进制表示以及如何创建类和接口。链接在第[5.4节中](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4)描述 。[§5.5](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5)详细说明了如何初始化类和接口。[§5.6](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.6) 介绍了绑定本机方法的概念。最后，[§5.7](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.7)描述了Java虚拟机何时退出。

### 运行时常量池

Java虚拟机为每个类和接口都维护一个运行时常量池，该数据结构用于传统编程语言实现的用于达到一些目所使用的符号表。类或接口的二进制表示形式中的constant_pool表用于在创建类或接口时构造运行时常量池。

运行时常量池中有两种类型的条目：符号引用（稍后可以解析）和静态常量（不需要进一步处理）。

运行时常量池中的符号引用是根据每个条目的结构从constant_pool表中的条目派生出来的：

- 对类或接口的符号引用是从CONSTANT_Class_info结构派生的。 这样的引用以下列形式给出了类或接口的名称：
  - 对于非数组类或接口，名称是类或接口的二进制名称。
  - 对于n维的数组类，名称以n次出现的ASCII开头[字符后跟元素类型的表示：
    - 如果元素类型是基本类型，则它由相应的字段描述符表示
    - 否则，如果元素类型是引用类型，则它由ASCII L字符表示，后跟元素类型的二进制名称，后跟ASCII; 字符。

每当本章引用类或接口的名称时，名称应理解为上面的形式。 （这也是`Class.getName`方法返回的表单。）

- 对类或接口的字段的符号引用是从CONSTANT_Fieldref_info结构派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。

- 对类的方法的符号引用是从CONSTANT_Methodref_info结构派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。

- 从CONSTANT_InterfaceMethodref_info结构派生对接口方法的符号引用。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。

- 方法句柄的符号引用是从CONSTANT_MethodHandle_info结构派生的。根据方法句柄的类型，这样的引用给出了类或接口的字段，类的方法或接口的方法的符号引用。

- 方法类型的符号引用是从CONSTANT_MethodType_info结构派生的。这样的引用给出了方法描述符。

- 动态计算常量的符号引用是从CONSTANT_Dynamic_info结构派生的。这样的参考给出：

  - 对方法句柄的符号引用，将调用它来计算常量的值;
  - 一系列符号引用和静态常量，在调用方法句柄时将用作静态参数
  - 不合格的名称和字段描述符。

- 对动态计算的调用站点的符号引用是从CONSTANT_InvokeDynamic_info结构派生的。 这样的参考给出：

  - 对方法句柄的符号引用，它将在 invokedynamic 指令的过程中调用，以计算java.lang.invoke.CallSite 的实例;
  - 一系列符号引用和静态常量，在调用方法句柄时将用作静态参数;
  - 不合格的名称和方法描述符。

- 运行时常量池中的静态常量也是根据每个条目的结构从constant_pool表中的条目派生的：

  - 字符串常量是对String类实例的引用，并且是从CONSTANT_String_info结构派生的。 为了派生字符串常量，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列：
    - 如果先前在类String的实例上调用了`String.intern`方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串常量是对类String的同一实例的引用。
    - 否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列。 字符串常量是对新实例的引用。 最后，在新实例上调用`String.intern`方法。

- 数字常量派生自CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info和CONSTANT_Double_info结构。                                       请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式的值。 因此，从这些结构导出的数值常数必须是可以分别使用IEEE 754单格式和双格式表示的值。

constant_pool表中的其余结构 - 描述性结构CONSTANT_NameAndType_info，CONSTANT_Module_info和CONSTANT_Package_info，以及基础结构CONSTANT_Utf8_info  - 仅在构造运行时常量池时间接使用。 运行时常量池中的条目不直接对应于这些结构。

运行时常量池中的某些条目是可加载的，这意味着：

* 它们可能会被ldc系列指令推入堆栈
* 它们可能是动态计算常量和调用站点的引导方法的静态参数

如果运行时常量池中的条目是从可加载的constant_pool表中的条目派生的，则该条目是可加载的。 因此，运行时常量池中的以下条目是可加载的：

* 对类和接口的符号引用

* 对方法类型的符号引用

* 对动态计算常量的符号引用

* 静态常量

### Java虚拟机启动

Java虚拟机通过使用bootstrap 类加载器或用户定义的类加载器创建初始类或接口来启动。 然后，Java虚拟机链接初始类或接口，对其进行初始化，并调用公共静态方法`public static method void main(String[])`。 调用此方法会驱动所有进一步操作的执行。 构成`main`方法的Java虚拟机指令的执行可以导致附加类和接口的链接（并因此创建），以及其他方法的调用。

## 类的加载和初始化

类的初始时机：

1. 遇到 new（使用new关键字实例化对象的时候）、getstatic、putstatic（读取或设置一个类的静态字段（被final字段修饰、已在编译期把结果放入常量池的静态字段除外））或invokestatic（调用静态方法） 这4 跳字节码指令时，如果类没有进行过初始化，则需要先出发初始化。
2. 使用 java.long.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化时，则需要先出发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。（对于接口，当一个接口被初始化的时候，并不需要其父接口全部完成初始化。而是等到调用其父接口的时候在将其初始化）
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main`方法的类），虚拟机会先初始化这个主类
5. 当使用JDK 1.7 的动态语言支持时，如果一个 java.long.invoke.MethodHandle 实例最后的解析结果是与静态变量或方法相关的句柄，并且方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

注意：

对于静态字段，只有直接定义这个字段的类才会被初始化，因此直接调用子类的静字段则只会加载子类。通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot 虚拟机来说，可通过 -XX:TraceClassLoading 参数观察到此操作会导致子类的加载。

对于数组，会由虚拟机生成一个直接继承与Object的字类，创建的动作由字节码指令 newArray 触发。这个类代表数组类型类的一位数组，数组中应有的类和方法都在这个虚拟机实现的类里。java语言对数组的访问控制（数组越界抛出 `java.long.ArrayIndexOutOfBoundsException`）就封装在这个类中。

对于常量，在编译阶段通过常量传播优化，已经将常量的值存储到调用类的常量池中，以后对该常量的引用已经变成对调用类的直接引用。

## 类的加载过程 

加载  链接（验证、准备解析） 初始化

在加载阶段，虚拟机需要完成以下三件事：

通过一个类的全限定名来获取定义此类的二进制字节流。

将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

在内存中生成一个代表这个类的 java.lang.Clas 对象，作为方法区中这个类的各种数据的访问入口。

下面是虚拟机规范原文：

## 创建和加载

由名称 N 表示的类或接口 C 由 Java 虚拟机的方法区中 C 的具体实现来创建。类或接口创建由另一个类或接口 D 触发，其通过运行是常量池引用 C。 类或接口创建也可能由某些Java SE Platform类库（如反射）中的 D 方法调用触发。

如果C不是数组类，则通过使用类加载器加载 C 的二进制表示来创建它。 数组类没有外部二进制表示; 它们是由Java虚拟机而不是类加载器创建的。

有两种类加载器：Java虚拟机提供的bootstrap类加载器和用户定义的类加载器。 每个用户定义的类加载器都是抽象类 ClassLoader 的子类的实例。 应用程序使用用户定义的类加载器，以扩展Java虚拟机动态加载的方式，从而创建类。 用户定义的类加载器可用于创建源自用户定义的源的类。 例如，可以通过网络下载类，即时生成或从加密文件中提取类。

类加载器L可以通过直接定义C或通过委托给另一个类加载器来创建C. 如果L直接创建C，我们说L定义C或者等价地说L是C的定义加载器。

当一个类加载器委托给另一个类加载器时，启动加载的加载器不一定与最终完成加载和定义的加载器相同。 如果L通过直接定义或通过委托来创建C，我们说L启动C的加载，或者等效地，L是C的启动加载器。

在运行时，类或接口不是由其名称单独确定，而是由一对确定：**它的类名及其定义的类加载器**。 每个这样的类或接口都属于一个 *run-time package*。 类或接口的运行时包由包名称和类或接口的类加载器定义。

Java虚拟机使用以下三个过程之一来创建由N表示的类或接口C：

- 如果N表示非阵数组或接口，则使用以下两种方法之一来加载，从而创建C：
  - 如果D由 bootstrap 类加载器定义，则引导类加载器启动加载C。
  - 如果D是由用户定义的类加载器定义的，那么同一个用户定义的类加载器会启动C的加载。
- 当N表示数组类。 数组类由Java虚拟机直接创建，而不是由类加载器创建。 但是，D的定义类加载器用于创建数组C的Class的过程中。

如果在类加载期间发生错误，则必须在程序中（直接或间接）使用正在加载的类或接口的某个点抛出LinkageError的子类的实例。

如果Java虚拟机在验证或解析期间（但不是初始化）尝试加载类C，并且用于启动C加载的类加载器抛出ClassNotFoundException的实例，那么Java虚拟机必须抛出一个实例 NoClassDefFoundError，其原因是ClassNotFoundException的实例。

（这里的一个细微之处在于，加载超类的递归类加载是作为解析的一部分执行的。因此，无法加载超类的类加载器导致的ClassNotFoundException必须包装在NoClassDefFoundError中。）

一个表现良好的类加载器应该保持三个属性：

* 给定相同的名称，一个好的类加载器应该总是返回相同的Class对象。
* 如果类加载器L1将类C的加载委托给另一个加载器L2，那么对于作为直接超类或C的直接超接口出现的任何类型T，或作为C中的字段类型，或作为类型 C中的方法或构造函数的形式参数，或者作为C，L1和L2中方法的返回类型应该返回相同的Class对象。
* 如果用户定义的类加载器预取类和接口的二进制表示，或者将一组相关的类加载在一起，那么它必须仅在程序中可能出现的位置反映加载错误，而无需预取或组加载。

我们有时使用符号<N，Ld>表示类或接口，其中N表示类或接口的名称，Ld表示类或接口的定义加载器。

我们还将使用符号NLi表示类或接口，其中N表示类或接口的名称，Li表示类或接口的启动加载器。

### 使用Bootstrap类加载器加载

以下步骤用于加载，从而使用引导类加载器创建由N表示的非阵列类或接口C。

首先，Java虚拟机确定引导类加载器是否已被记录为由N表示的类或接口的初始加载器。如果是，则此类或接口是C，并且不需要创建类。

否则，Java虚拟机将参数N传递给引导类加载器上的方法调用，以依赖于平台的方式搜索声称的C表示。 通常，将使用分层文件系统中的文件来表示类或接口，并且类或接口的名称将在文件的路径名中进行编码。

请注意，无法保证找到的声称表示有效或是C的表示。此加载阶段必须检测以下错误：请注意，无法保证找到的声称表示有效或是C的表示。 此加载阶段必须检测以下错误：

* 如果没有找到C的声称表示，则加载会抛出ClassNotFoundException的实例。

然后，Java虚拟机尝试使用引用的表示中的引导类加载器使用找到的算法派生由N表示的类。该类是C。

### 使用用户定义的类加载器加载

以下步骤用于加载，从而使用用户定义的类加载器 L 创建由N表示的非阵列类或接口 C。

首先，Java虚拟机确定 L 是否已被标记为由N表示的类或接口的初始加载器。如果是则说明该类或接口已经被加载，则此类或接口是就是C，并且不需要再创建类。

否则，Java虚拟机在L上调用`loadClass（N）`。调用返回的值是创建的类或接口C。然后Java虚拟机记录L 是 类或接口 C 的启动加载器。本节的其余部分将更详细地介绍此过程。

当使用要加载的类或接口C的名称N调用类加载器L的`loadClass`方法时，L必须执行以下两个操作之一才能加载C：

1. 类加载器L可以创建一个字节数组，表示C作为ClassFile结构的字节; 然后它必须调用类ClassLoader的方法`defineClass`。 调用defineClass会导致Java虚拟机使用找到的算法从字节数组中使用L来导出由N表示的类或接口。
2. 类加载器L可以将C的加载委托给其他类加载器L`。 这是通过将参数N直接或间接传递给L'上的方法调用（通常是loadClass方法）来实现的。 调用的结果是C。

在（1）或（2）中，如果类加载器L由于任何原因无法加载由N表示的类或接口，则它必须抛出`ClassNotFoundException`的实例。

从JDK 1.1版开始，Oracle的Java虚拟机实现调用了类加载器的`loadClass`方法，以使其加载类或接口。 `loadClass`的参数是要加载的类或接口的名称。 还有loadClass方法的两个参数版本，其中第二个参数是一个布尔值，指示是否要链接类或接口。 JDK版本1.0.2中仅提供了双参数版本，Oracle的Java虚拟机实现依赖于它来链接加载的类或接口。 从JDK 1.1版开始，**Oracle的Java虚拟机实现直接链接类或接口，而不依赖于类加载器**。

### 创建数组类

以下步骤用于使用类加载器L创建由N表示的数组类C。类加载器L可以是引导类加载器或用户定义的类加载器。

如果L已经被记录为具有与N相同的组件类型的数组类的初始加载器，则该类是C，并且不需要创建数组类Class。

否则，执行以下步骤来创建C：

1. 如果组件类型是引用类型，则使用类加载器 L 递归地应用此部分的算法以便加载并由此创建C的组件类型。

2. **Java虚拟机使用指示的组件类型和维数创建一个新的数组类**。

   如果组件类型是引用类型，则C被标记为已由组件类型的定义类加载器定义。 否则，C被标记为已由 bootstrap类加载器定义。

   在任何情况下，Java虚拟机在上述之后记录L是C的启动加载器。

   如果组件类型是引用类型，则数组类的可访问性由其组件类型的可访问性决定。 否则，所有类和接口都可以访问数组类。

### 加载约束

在多个类加载器的存在下确保类型安全联动。 当两个不同的类加载器启动加载由N表示的类或接口时，在两个加载器中class N 有可能被标记为两个不同的类或接口。

当类或接口C = <N1，L1>对另一个类或接口D = <N2，L2>的字段或方法进行符号引用时，符号引用包括指定字段类型或返回的描述符 和方法的参数类型。 当由L1加载和由L2加载时，字段或方法描述符中提到的任何类型名称N必须表示相同的类或接口。

为确保这一点，Java虚拟机在准备和解析期间强制使用形式为N（L1） = N（L2）的加载约束。 为了实施这些约束，Java虚拟机将在某些规定的时间记录特定加载器是特定类的启动加载器。 在记录加载器是类的初始加载器之后，Java虚拟机必须立即检查以查看是否违反了任何加载约束。 如果是，则撤消记录，Java虚拟机抛出LinkageError，导致记录发生的加载操作失败。

类似地，在施加加载约束之后，Java虚拟机必须立即检查以查看是否违反了任何加载约束。 如果是这样，则撤消新强加的加载约束，Java虚拟机抛出LinkageError，并且导致约束的操作（resolution 或preparation，视情况而定）失败。

## 链接

### 验证

*验证* 确保类或接口的二进制表示在结构上是正确的。验证可能会导致加载其他类和接口，但不需要对它们进行验证或准备。

如果类或接口的二进制表示不满足列出的静态或结构约束，则`VerifyError`必须抛出程序中导致验证类或接口的点。

如果Java虚拟机尝试验证类或接口失败，因为抛出的错误是`LinkageError`（或子类）的实例，则后续尝试验证类或接口始终失败并返回相同的错误初始验证尝试的结果。

验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证

   第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会在直接操作字节流。

2. 元数据验证

   第二阶段是对字节码描述的信息进行予以分析，以保证其描述的信息符合java语言规范的要求，这个阶段可能包括的验证比如：该类是否有父类，这个类是否继承了不允许被继承的类……

3. 字节码验证

   第三个阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流个控制流分析，确定程序予以是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：保证跳转指令不会跳转到方法体之外。保证方法体中的类型转换是有效的。

4. 符号引用验证

   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：符号引用中通过字符串描述的全限定名是都能找到对应的类、符号引用中的类、字段、方法的访问性手否可以被当前类进行访问。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。（这时候进行内存分配的进包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值）

假如一个类变量：`public static intvalue = 123`

那变量value在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 java 方法，而把value 赋值为 123 的 putstastic 指令在程序被编译后，存放于类构造器<clinit>方法中，等到初始化阶段才将赋值动作执行。

## 解析

解析阶段是虚拟机将常量池内的符号引用提花那位直接引用的过程。

符号引用：符号引用以一组符号来描述锁引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中。

直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的的直接引用一般不会相同。如果有了直接用，那引用的目标必定已经在内存中存在。

### 初始化

初始化阶段是类在加载过程中的最后一步，前面的加载过程中，除了加载阶段用户应用程序可以通过自定义加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的的主观计划去初始化类变量和其他资源，或者可以从另外一个角度表达：初始化阶段是执行类构造器<clinit>方法的过程。

<clinit>方法时候编译器自动收集类中的所有类变量和赋值动作和静态语句块中的语句合并产生的编译器收集的顺序是由语句在原文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

<clinit>方法与类的构造函数（或者说实例构造器<init方法>）不同，它不需要显示地调用父类的构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。因此在虚拟机执行中第一个被执行的<clinit>方法的类肯定是java.long.object。

由于父类