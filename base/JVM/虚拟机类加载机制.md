## 加载、链接和初始化

注意:以下由类加载器创建的都代表Class类。

------



Java虚拟机动态加载，链接和初始化类和接口。加载是查找具有特定名称的类或接口类型的二进制表示并从该二进制表示*创建*类或接口的过程。链接是获取类或接口并将其组合到Java虚拟机的运行时状态以便可以执行的过程。类或接口的初始化包括执行类或接口初始化方法`<clinit>`。

在本章中，第 [5.1节](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.1)描述了Java虚拟机如何从类或接口的二进制表示中派生符号引用。[§5.2](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2)解释了如何首先由Java虚拟机启动加载，链接和初始化的过程。[§5.3](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.3)指定类加载器如何加载类和接口的二进制表示以及如何创建类和接口。链接在第[5.4节中](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4)描述 。[§5.5](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5)详细说明了如何初始化类和接口。[§5.6](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.6) 介绍了绑定本机方法的概念。最后，[§5.7](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.7)描述了Java虚拟机何时退出。

### 运行时常量池

Java虚拟机为每个类和接口都维护一个运行时常量池，该数据结构用于传统编程语言实现的用于达到一些目所使用的符号表。类或接口的二进制表示形式中的constant_pool表用于在创建类或接口时构造运行时常量池。

运行时常量池中有两种类型的条目：符号引用（稍后可以解析）和静态常量（不需要进一步处理）。

运行时常量池中的符号引用是根据每个条目的结构从constant_pool表中的条目派生出来的：

- 对类或接口的符号引用是从CONSTANT_Class_info结构派生的。 这样的引用以下列形式给出了类或接口的名称：
  - 对于非数组类或接口，名称是类或接口的二进制名称。
  - 对于n维的数组类，名称以n次出现的ASCII开头[字符后跟元素类型的表示：
    - 如果元素类型是基本类型，则它由相应的字段描述符表示
    - 否则，如果元素类型是引用类型，则它由ASCII L字符表示，后跟元素类型的二进制名称，后跟ASCII; 字符。

每当本章引用类或接口的名称时，名称应理解为上面的形式。 （这也是`Class.getName`方法返回的表单。）

- 对类或接口的字段的符号引用是从CONSTANT_Fieldref_info结构派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。
- 对类的方法的符号引用是从CONSTANT_Methodref_info结构派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。
- 从CONSTANT_InterfaceMethodref_info结构派生对接口方法的符号引用。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。
- 方法句柄的符号引用是从CONSTANT_MethodHandle_info结构派生的。根据方法句柄的类型，这样的引用给出了类或接口的字段，类的方法或接口的方法的符号引用。
- 方法类型的符号引用是从CONSTANT_MethodType_info结构派生的。这样的引用给出了方法描述符。
- 动态计算常量的符号引用是从CONSTANT_Dynamic_info结构派生的。这样的参考给出：
  - 对方法句柄的符号引用，将调用它来计算常量的值;
  - 一系列符号引用和静态常量，在调用方法句柄时将用作静态参数
  - 不合格的名称和字段描述符。
- 对动态计算的调用站点的符号引用是从CONSTANT_InvokeDynamic_info结构派生的。 这样的参考给出：
  - 对方法句柄的符号引用，它将在 invokedynamic 指令的过程中调用，以计算java.lang.invoke.CallSite 的实例;
  - 一系列符号引用和静态常量，在调用方法句柄时将用作静态参数;
  - 不合格的名称和方法描述符。
- 运行时常量池中的静态常量也是根据每个条目的结构从constant_pool表中的条目派生的：
  - 字符串常量是对String类实例的引用，并且是从CONSTANT_String_info结构派生的。 为了派生字符串常量，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列：
    - **如果先前在类String的实例上调用了`String.intern`方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串常量是对类String的同一实例的引用。**
    - **否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列。 字符串常量是对新实例的引用。 最后，在新实例上调用`String.intern`方法。**
- 数字常量派生自CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info和CONSTANT_Double_info结构。                                       
- 请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式的值。 因此，从这些结构导出的数值常数必须是可以分别使用IEEE 754单格式和双格式表示的值。

constant_pool表中的其余结构 - 描述性结构CONSTANT_NameAndType_info，CONSTANT_Module_info和CONSTANT_Package_info，以及基础结构CONSTANT_Utf8_info  - 仅在构造运行时常量池时间接使用。 运行时常量池中的条目不直接对应于这些结构。

运行时常量池中的某些条目是可加载的，这意味着：

- 它们可能会被ldc系列指令推入堆栈
- 它们可能是动态计算常量和调用站点的引导方法的静态参数

如果运行时常量池中的条目是从可加载的constant_pool表中的条目派生的，则该条目是可加载的。 因此，运行时常量池中的以下条目是可加载的：

- 对类和接口的符号引用
- 对方法类型的符号引用
- 对动态计算常量的符号引用
- 静态常量

### Java虚拟机启动

Java虚拟机通过使用bootstrap 类加载器或用户定义的类加载器创建初始类或接口来启动。 然后，Java虚拟机链接初始类或接口，对其进行初始化，并调用公共静态方法`public static method void main(String[])`。 调用此方法会驱动所有进一步操作的执行。 构成`main`方法的Java虚拟机指令的执行可以导致附加类和接口的链接（并因此创建），以及其他方法的调用。

## 类的加载和初始化

**类的初始化时机：**

1. **遇到 new（使用new关键字实例化对象的时候）、getstatic、putstatic（读取或设置一个类的静态字段（被final字段修饰、已在编译期把结果放入常量池的静态字段除外））或invokestatic（调用静态方法） 这4 跳字节码指令时，如果类没有进行过初始化，则需要先出发初始化。**
2. **使用 java.long.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化时，则需要先出发其初始化。**
3. **当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。（对于接口，当一个接口被初始化的时候，并不需要其父接口全部完成初始化。而是等到调用其父接口的时候在将其初始化）**
4. **当虚拟机启动时，用户需要指定一个要执行的主类（包含`main`方法的类），虚拟机会先初始化这个主类**
5. **当使用JDK 1.7 的动态语言支持时，如果一个 java.long.invoke.MethodHandle 实例最后的解析结果是与静态变量或方法相关的句柄，并且方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。**

**注意：**

**对于静态字段，只有直接定义这个字段的类才会被初始化，因此直接调用子类的静字段则只会加载子类。通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot 虚拟机来说，可通过 -XX:TraceClassLoading 参数观察到此操作会导致子类的加载。**

**对于数组，会由虚拟机生成一个直接继承于Object的子类，创建的动作由字节码指令 newArray 触发。这个类代表数组类型类的一维数组，数组中应有的类和方法都在这个虚拟机实现的类里。java语言对数组的访问控制（数组越界抛出 `java.long.ArrayIndexOutOfBoundsException`）就封装在这个类中。**

**对于常量，在编译阶段通过常量传播优化，已经将常量的值存储到调用类的常量池中，以后对该常量的引用已经变成对调用类的直接引用。**

## 以下是JVM规范原文：

## 12.4。类和接口的初始化

类的*初始化*包括执行其静态初始化程序和`static`类中声明的字段（类变量）的初始化程序。

*初始化* 的接口由执行用于字段（常数）的初始化的接口中声明。

### 12.4.1。发生初始化时

类或接口类型T将在第一次出现以下任何一个之前立即初始化：

- T是一个类，并且创建了T的实例。
- 阿`static`通过声明的方法Ť被调用。
- 阿`static`通过声明字段Ť被分配。
- 使用`static`由T声明的字段，该字段不是常量变量（第[4.12.4节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4)）。

初始化类时，初始化其超类（如果它们之前未初始化），以及声明任何默认方法（第[9.4.3节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）的任何超接口（第[8.1.5 ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.5)[节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）（如果它们之前未初始化） ）。接口的初始化本身不会导致其任何超接口的初始化。

对`static`字段的引用（第[8.3.1.1节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1)）仅导致实际声明它的类或接口的初始化，即使它可能通过子类的名称，子接口或实现接口的类来引用。

在类`Class`和包中调用某些反射方法`java.lang.reflect`也会导致类或接口初始化。

在任何其他情况下，不会初始化类或接口。

请注意，编译器可能会 在接口中生成*合成*默认方法，即既未显式也未隐式声明的默认方法。尽管源代码没有给出应该初始化接口的指示，但是这样的方法将触发接口的初始化。

目的是类或接口类型具有一组初始化器，使其处于一致状态，并且该状态是其他类观察到的第一个状态。静态初始值设定项和类变量初始值设定项以文本顺序执行，并且可能不引用在声明在使用后以文本方式出现的类中声明的类变量，即使这些类变量在范围内。此限制旨在在编译时检测大多数循环或其他格式错误的初始化。

初始化代码不受限制的事实允许构造示例，其中在其初始化表达式被评估之前，当它仍然具有其初始默认值时可以观察到类变量的值，但是这样的示例在实践中是罕见的。（这些示例也可以构造为例如变量初始化。）这些初始化器中提供了Java编程语言的全部功能。程序员必须小心谨慎。这种能力给代码生成器带来了额外的负担，但是在任何情况下都会产生这种负担，因为Java编程语言是并发的.

## 类的加载过程 

加载  链接（验证、准备、解析） 初始化

在加载阶段，虚拟机需要完成以下三件事：

通过一个类的全限定名来获取定义此类的二进制字节流。

将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

在内存中生成一个代表这个类的 java.lang.Clas 对象，作为方法区中这个类的各种数据的访问入口。

下面是虚拟机规范原文：

## 创建和加载

由名称 N 表示的类或接口 C 由 Java 虚拟机的方法区中 C 的具体实现来创建。类或接口创建由另一个类或接口 D 触发，其通过运行是常量池引用 C。 类或接口创建也可能由某些Java SE Platform类库（如反射）中的 D 方法调用触发。

如果C不是数组类，则通过使用类加载器加载 C 的二进制表示来创建它。 数组类没有外部二进制表示; 它们是由Java虚拟机而不是类加载器创建的。

有两种类加载器：Java虚拟机提供的bootstrap类加载器和用户定义的类加载器。 每个用户定义的类加载器都是抽象类 ClassLoader 的子类的实例。 应用程序使用用户定义的类加载器，以扩展Java虚拟机动态加载的方式，从而创建类。 用户定义的类加载器可用于创建源自用户定义的源的类。 例如，可以通过网络下载类，即时生成或从加密文件中提取类。

类加载器L可以通过直接定义C或通过委托给另一个类加载器来创建C. 如果L直接创建C，我们说L定义C或者等价地说L是C的定义加载器。

当一个类加载器委托给另一个类加载器时，启动加载的加载器不一定与最终完成加载和定义的加载器相同。 如果L通过直接定义或通过委托来创建C，我们说L启动C的加载，或者等效地，L是C的启动加载器。

在运行时，类或接口不是由其名称单独确定，而是由一对确定：**它的类名及其定义的类加载器**。 每个这样的类或接口都属于一个 *run-time package*。 类或接口的运行时包由包名称和类或接口的类加载器定义。

Java虚拟机使用以下三个过程之一来创建由N表示的类或接口C：

- 如果N表示非阵数组或接口，则使用以下两种方法之一来加载，从而创建C：
  - 如果D由 bootstrap 类加载器定义，则引导类加载器启动加载C。
  - 如果D是由用户定义的类加载器定义的，那么同一个用户定义的类加载器会启动C的加载。
- 当N表示数组类。 数组类由Java虚拟机直接创建，而不是由类加载器创建。 但是，D的定义类加载器用于创建数组C的Class的过程中。

如果在类加载期间发生错误，则必须在程序中（直接或间接）使用正在加载的类或接口的某个点抛出LinkageError的子类的实例。

如果Java虚拟机在验证或解析期间（但不是初始化）尝试加载类C，并且用于启动C加载的类加载器抛出ClassNotFoundException的实例，那么Java虚拟机必须抛出一个实例 NoClassDefFoundError，其原因是ClassNotFoundException的实例。

（这里的一个细微之处在于，加载超类的递归类加载是作为解析的一部分执行的。因此，无法加载超类的类加载器导致的ClassNotFoundException必须包装在NoClassDefFoundError中。）

一个表现良好的类加载器应该保持三个属性：

- 给定相同的名称，一个好的类加载器应该总是返回相同的Class对象。
- 如果类加载器L1将类C的加载委托给另一个加载器L2，那么对于作为直接超类或C的直接超接口出现的任何类型T，或作为C中的字段类型，或作为类型 C中的方法或构造函数的形式参数，或者作为C，L1和L2中方法的返回类型应该返回相同的Class对象。
- 如果用户定义的类加载器预取类和接口的二进制表示，或者将一组相关的类加载在一起，那么它必须仅在程序中可能出现的位置反映加载错误，而无需预取或组加载。

我们有时使用符号<N，Ld>表示类或接口，其中N表示类或接口的名称，Ld表示类或接口的定义加载器。

我们还将使用符号NLi表示类或接口，其中N表示类或接口的名称，Li表示类或接口的启动加载器。

### 使用Bootstrap类加载器加载

以下步骤用于加载，从而使用引导类加载器创建由N表示的非阵列类或接口C。

首先，Java虚拟机确定引导类加载器是否已被记录为由N表示的类或接口的初始加载器。如果是，则此类或接口是C，并且不需要创建类。

否则，Java虚拟机将参数N传递给引导类加载器上的方法调用，以依赖于平台的方式搜索声称的C表示。 通常，将使用分层文件系统中的文件来表示类或接口，并且类或接口的名称将在文件的路径名中进行编码。

请注意，无法保证找到的声称表示有效或是C的表示。此加载阶段必须检测以下错误：请注意，无法保证找到的声称表示有效或是C的表示。 此加载阶段必须检测以下错误：

- 如果没有找到C的声称表示，则加载会抛出ClassNotFoundException的实例。

然后，Java虚拟机尝试使用引用的表示中的引导类加载器使用找到的算法派生由N表示的类。该类是C。

### 使用用户定义的类加载器加载

以下步骤用于加载，从而使用用户定义的类加载器 L 创建由N表示的非阵列类或接口 C。

首先，Java虚拟机确定 L 是否已被标记为由N表示的类或接口的初始加载器。如果是则说明该类或接口已经被加载，则此类或接口是就是C，并且不需要再创建类。

否则，Java虚拟机在L上调用`loadClass（N）`。调用返回的值是创建的类或接口C。然后Java虚拟机记录L 是 类或接口 C 的启动加载器。本节的其余部分将更详细地介绍此过程。

当使用要加载的类或接口C的名称N调用类加载器L的`loadClass`方法时，L必须执行以下两个操作之一才能加载C：

1. 类加载器L可以创建一个字节数组，表示C作为ClassFile结构的字节; 然后它必须调用类ClassLoader的方法`defineClass`。 调用defineClass会导致Java虚拟机使用找到的算法从字节数组中使用L来导出由N表示的类或接口。
2. 类加载器L可以将C的加载委托给其他类加载器L`。 这是通过将参数N直接或间接传递给L'上的方法调用（通常是loadClass方法）来实现的。 调用的结果是C。

在（1）或（2）中，如果类加载器L由于任何原因无法加载由N表示的类或接口，则它必须抛出`ClassNotFoundException`的实例。

从JDK 1.1版开始，Oracle的Java虚拟机实现调用了类加载器的`loadClass`方法，以使其加载类或接口。 `loadClass`的参数是要加载的类或接口的名称。 还有loadClass方法的两个参数版本，其中第二个参数是一个布尔值，指示是否要链接类或接口。 JDK版本1.0.2中仅提供了双参数版本，Oracle的Java虚拟机实现依赖于它来链接加载的类或接口。 从JDK 1.1版开始，**Oracle的Java虚拟机实现直接链接类或接口，而不依赖于类加载器**。

### 创建数组类

以下步骤用于使用类加载器L创建由N表示的数组类C。类加载器L可以是引导类加载器或用户定义的类加载器。

如果L已经被记录为具有与N相同的组件类型的数组类的初始加载器，则该类是C，并且不需要创建数组类Class。

否则，执行以下步骤来创建C：

1. 如果组件类型是引用类型，则使用类加载器 L 递归地应用此部分的算法以便加载并由此创建C的组件类型。

2. **Java虚拟机使用指示的组件类型和维数创建一个新的数组类**。

   如果组件类型是引用类型，则C被标记为已由组件类型的定义类加载器定义。 否则，C被标记为已由 bootstrap类加载器定义。

   在任何情况下，Java虚拟机在上述之后记录L是C的启动加载器。

   如果组件类型是引用类型，则数组类的可访问性由其组件类型的可访问性决定。 否则，所有类和接口都可以访问数组类。

### 加载约束

在多个类加载器的存在下确保类型安全联动。 当两个不同的类加载器启动加载由N表示的类或接口时，在两个加载器中class N 有可能被标记为两个不同的类或接口。

当类或接口C = <N1，L1>对另一个类或接口D = <N2，L2>的字段或方法进行符号引用时，符号引用包括指定字段类型或返回的描述符 和方法的参数类型。 当由L1加载和由L2加载时，字段或方法描述符中提到的任何类型名称N必须表示相同的类或接口。

为确保这一点，Java虚拟机在准备和解析期间强制使用形式为N（L1） = N（L2）的加载约束。 为了实施这些约束，Java虚拟机将在某些规定的时间记录特定加载器是特定类的启动加载器。 在记录加载器是类的初始加载器之后，Java虚拟机必须立即检查以查看是否违反了任何加载约束。 如果是，则撤消记录，Java虚拟机抛出LinkageError，导致记录发生的加载操作失败。

类似地，在施加加载约束之后，Java虚拟机必须立即检查以查看是否违反了任何加载约束。 如果是这样，则撤消新强加的加载约束，Java虚拟机抛出LinkageError，并且导致约束的操作（resolution 或preparation，视情况而定）失败。

## 链接

### 验证

*验证* 确保类或接口的二进制表示在结构上是正确的。验证可能会导致加载其他类和接口，但不需要对它们进行验证或准备。

如果类或接口的二进制表示不满足列出的静态或结构约束，则`VerifyError`必须抛出程序中导致验证类或接口的点。

如果Java虚拟机尝试验证类或接口失败，因为抛出的错误是`LinkageError`（或子类）的实例，则后续尝试验证类或接口始终失败并返回相同的错误初始验证尝试的结果。

验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证

   第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会在直接操作字节流。

2. 元数据验证

   第二阶段是对字节码描述的信息进行予以分析，以保证其描述的信息符合java语言规范的要求，这个阶段可能包括的验证比如：该类是否有父类，这个类是否继承了不允许被继承的类……

3. 字节码验证

   第三个阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流个控制流分析，确定程序予以是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：保证跳转指令不会跳转到方法体之外。保证方法体中的类型转换是有效的。

4. 符号引用验证

   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：符号引用中通过字符串描述的全限定名是都能找到对应的类、符号引用中的类、字段、方法的访问性手否可以被当前类进行访问。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。（这时候进行内存分配的进包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值）

假如一个类变量：`public static intvalue = 123`

那变量value在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 java 方法，而把value 赋值为 123 的 putstastic 指令在程序被编译后，存放于类构造器<clinit>方法中，等到初始化阶段才将赋值动作执行。

## 解析

解析阶段是虚拟机将常量池内的符号引用提花那位直接引用的过程。

符号引用：符号引用以一组符号来描述锁引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中。

直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的的直接引用一般不会相同。如果有了直接用，那引用的目标必定已经在内存中存在。

### 初始化

初始化阶段是类在加载过程中的最后一步，前面的加载过程中，除了加载阶段用户应用程序可以通过自定义加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的的主观计划去初始化类变量和其他资源，或者可以从另外一个角度表达：初始化阶段是执行类构造器<clinit>方法的过程。

<clinit>方法时候编译器自动收集类中的所有类变量和赋值动作和静态语句块中的语句合并产生的编译器收集的顺序是由语句在原文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

<clinit>方法与类的构造函数（或者说实例构造器<init方法>）不同，它不需要显示地调用父类的构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。因此在虚拟机执行中第一个被执行的<clinit>方法的类肯定是java.long.object。

由于父类<clinit>方法先执行，也就意味着父类中定义的静态语句块要先由于子类的变量赋值操作。

<clinit>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法。但接口与类不同的是，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法。只有当父类接口中定义的变量使用时父类接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>方法。

虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只有一个线程取执行这个类的<clinit>方法。其他线程都需要阻塞等待，知道活动线程执行<clinit>方法完毕。如果一个类的<clinit>方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。



## 类加载器

------

## ClassLoader

类加载器是一个负责加载类的对象。 ClassLoader类是一个抽象类。 给定类的二进制名称，类加载器应尝试定位或生成哪些构成类定义的数据。 典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。

每个Class对象都包含对定义它的ClassLoader的引用。

**数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。** `Class.getClassLoader（）`返回的数组类的类加载器与其元素类型的类加载器相同; 如果元素类型是基本类型，则数组类没有类加载器。

应用程序实现ClassLoader的子类，以便扩展Java虚拟机动态加载类的方式。

安全管理器通常可以使用类加载器来指示安全域。

除了加载类之外，类加载器还负责定位资源。 资源是一些数据（例如“.class”文件，配置数据或图像），用抽象的“/”分隔的路径名称标识。 资源通常与应用程序或库打包在一起，以便可以通过应用程序或库中的代码来定位它们。 在某些情况下，会包含资源，以便其他库可以找到它们。

ClassLoader类使用委派模型来搜索类和资源。 ClassLoader的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader实例通常会在尝试查找类或资源本身之前将对类或资源的搜索委托给其父类加载器。

支持并发加载类的类加载器称为并行加载类加载器，需要通过调用`ClassLoader.registerAsParallelCapable`方法在类初始化时注册自己。请注意，ClassLoader类默认注册为并行。但是，如果它们具有并行能力，它的子类仍然需要注册自己。在委托模型不是严格分层的环境中，类加载器需要具有并行能力，否则类加载会导致死锁，因为加载器锁在类加载过程的持续时间内保持（请参阅loadClass方法）。

### 运行时内置类加载器

从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，该加载器由C++实现，是虚拟机自身的一部分；另一部分就是所有其他类的加载器，这些类加载器都是由java语言实现，独立于虚拟机外部，并且全部继承于类 `java.lang.ClassLoader`。

Java运行时具有以下内置类加载器：

- Bootstrap类加载器。它是虚拟机的内置类加载器，通常表示为null，并且没有父加载器。

- Platform 加载器。平台类加载器可以看到所有平台类，它们可以用作ClassLoader实例的父级。平台类包括Java SE平台API，它们的实现类和JDK特定的运行时类由平台类加载器或其祖先定义。

  为了允许 升级/覆盖  定义到 Platform 类加载器的模块，并且升级后的模块读取定义到除Platform 类加载器及其祖先之外的类加载器的模块，那么Platform 类加载器可能必须委托给其他类加载器，例如，application 类加载器。换句话说，Platform 类加载器可以看到定义到除Platform 类加载器及其祖先之外的类加载器的命名模块中的类。

- System类加载器。它也称为 application 类加载器，与 Platform 类加载器不同。System 类加载器通常用于在应用程序类路径，模块路径和JDK特定工具上定义类。Platform 类加载器是系统类加载器的父级或祖先，所有平台类都是可见的。

对于任意一个类，都由类加载器和这个类本身确定该类在虚拟机中的唯一性。通常，Java虚拟机以与平台相关的方式从本地文件系统加载类。 但是，某些类可能不是源自文件; 它们可能来自其他来源，例如网络，或者它们可以由应用程序构建。 方法`defineClass`将字节数组转换为类Class的实例。 可以使用`Class.newInstance`创建此新定义的类的实例。

由类加载器创建的对象的方法和构造函数可以引用其他类。 要确定所引用的类，Java虚拟机将调用最初创建该类的类加载器的loadClass方法。

例如，应用程序可以通过本地加载器加载本地的class文件。 示例代码可能如下所示：

```java
   public static void main(String[] args) {

        try {
            myClassLoader classLoader = new myClassLoader();
            Object object = classLoader.loadClass("ClassLoaderTest").getDeclaredConstructor().newInstance();
            Method ob = object.getClass().getDeclaredMethod("test", null);
            ob.setAccessible(true);
            ob.invoke(object);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

```

本地加载器子类必须定义方法`findClass`和`loadClassData`以从本地加载类。 程序获取构成类的字节，就应该使用`defineClass`方法创建一个类实例。 示例实现是：

```java
static class myClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {


            BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("C:\\KnowledgeBase\\src\\main\\java\\mtest\\ClassLoaderTest.class"));

            byte[] bytes1 = new byte[bufferedInputStream.available()];
            bufferedInputStream.read(bytes1);

            return defineClass(name, bytes1, 0, bytes1.length);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;


    }

}
```



### 全限定名

作为ClassLoader中传递类名方法（`defineClass`、`loadClass`）的String参数提供的任何类名必须是The Java™Language Specification定义的全限定名。

有效类名的示例包括：

```java
   "java.lang.String"
   "javax.swing.JSpinner$DefaultEditor"
   "java.security.KeyStore$Builder$FileBuilder$1"
   "java.net.URLClassLoader$3$1"
```

作为ClassLoader中方法的String参数提供的任何包名称必须是空字符串（表示未命名的包）或由Java™语言规范定义的完全限定名称。

## 双亲委派模型

双亲委派模型要求除了顶层的Bootstrap 类加载器之外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般是以组合方式复用父类的代码而不是继承。

工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类去完成，每一个层次的类都是如此，因此所有的加载请求最终都应该传送到顶层的Bootstrap 类加载器中，只有当父类加载器无法自己完成这个加载请求时（它的搜索范围中没有找到所需要的类），子类加载器才会尝试自己加载。

对于Object类来说，双亲委派模型确保在各种类加载器环境中，类的一致性。保证了java体系中最基础的行为。

双亲委派模型的逻辑集中在 `java.lang.ClassLoder`中：

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 如果从非null父类加载器中找不到类，则抛出
                //ClassNotFoundException
            }

            if (c == null) {
                // 如果仍未找到，则调用findClass以查找该类。
                long t1 = System.nanoTime();
                c = findClass(name);

                // 这是定义的类加载器; 记录统计数据
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

为了保证Class 类值被加载一次，需要对Class加上锁。如果有父类加载器，则调用父类加载器去加载类，如果没有父类，则尝试调用启动类加载器去加载。如果非空的父类加载器中找不到类，则会抛出异常。若仍为找到，调用`findClass`方法进行加载。`findClass`需要调用`defineClass`将需要加载类的字节码转换成Class。

## 破坏双亲委派模型

双亲委派模型并不是一个强制性的约束模型，而是java设计者，推荐给开发者的类加载器实现方式。在java的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。

双亲委派模型的第一次被破发生在双亲委派模型出现之前，即 JDK-1.2发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0时代就已经存在，面对已经存在用户自定义类加载器的实现代码，java设计者在引入双亲委派模型的时候不得不做出一些妥协。为了向前兼容，JDK 1.2 之后的`java.lang.ClassLoader`添加了一个新的`protected`方法`findClass`。在此之前，用户去继承`java.lang.ClassLoader`的唯一目的就是为了重写`loadClass`方法。 JDK 1.2 之后已经不提倡用户重写`loadClass`方法，而是重写	`findClass`方法，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

双亲委派模型的第二次被破坏是由于这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的类加载器进行加载）。基础类之所以被称为“基础”,是因为他们总是作为被用户代码调用的API，但实际上还会出现基础类调用用户的代码的情况,一个典型的例子就是JNDI服务,JNDI现在已经是java的标准服务。它的代码由启动类加载器去加载，

但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI）的代码，但启动类加载器不可能在它的范围内找到这些代码。为了解决这个问题，java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器。这个类加载器可以通过 `java.lang.Thread`类的`setContextClassLoader`方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是System类加载器。JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类的加载。java中所有涉及SPI的加载动作基本上都采用了这种方式，如JNDI,JDBC等等。

双亲委派模型的第三次被破坏，是由于对应用程序动态性的追求导致的，这里所说的动态性指的是当前一些非常热门的名词，代码热替换（HotSwap）、模块热部署等，目前OSGI已经成为了业界的java模块化标准，而OSGI实现模块化热部署的关键则是他自定义的类加载机制的实现。每一个程序模块（OSGI中成为Bundle）都有一个自己的类加载器,当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网结构。