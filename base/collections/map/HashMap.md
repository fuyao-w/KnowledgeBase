## HashMap ##

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable 
```

### java doc ###

基于哈希表的Map接口实现。此实现提供所有可选的映射操作，并允许空值和空键。 （HashMap类大致相当于Hashtable，除了它是不同步的并且允许空值。）这个类不保证Map的顺序;特别是，它不保证订单会随着时间的推移保持不变。
假设散列函数在桶之间正确地分散元素，该实现为基本操作（get和put）提供了恒定时间性能。对集合视图的迭代需要与HashMap实例的“容量”（桶的数量）加上其大小（键 - 值映射的数量）成比例的时间。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载因子太低）非常重要。

HashMap的一个实例有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中的桶数，初始容量只是创建哈希表时的容量。加载因子是在自动增加容量之前允许哈希表获取的完整程度的度量。当哈希表中的条目数超过加载因子和当前容量的乘积时，哈希表将被重新哈希（即，重建内部数据结构），以便哈希表具有大约两倍的桶数。

作为一般规则，默认加载因子（.75）在时间和空间成本之间提供了良好的折衷。较高的值会减少空间开销，但会增加查找成本（反映在HashMap类的大多数操作中，包括get和put）。在设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以便最小化重新散列操作的数量。如果初始容量大于最大条目数除以加载因子，则不会发生重新加载操作。

如果要将多个映射存储在HashMap实例中，则使用足够大的容量创建映射将允许映射更有效地存储，而不是根据需要执行自动重新散列来扩展表。请注意，使用具有相同`hashCode()`的许多键可以使任何哈希表的性能下降。为了改善影响，当键是可比较时，该类可以使用键之间的比较顺序来帮助打破关系。

请注意，此实现不同步。如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，则必须在外部进行同步。 （结构修改是添加或删除一个或多个映射的任何操作;仅更改与实例已包含的键相关联的值不是结构修改。）这通常通过同步自然封装映射的某个对象来完成。 。如果不存在此类对象，则应使用Collections.synchronizedMap方法“包装”该映射。这最好在创建时完成，以防止意外地不同步访问Map：

```java
  Map m = Collections.synchronizedMap(new HashMap(...));
```

所有这个类的“集合视图方法”返回的迭代器都是快速失败的：如果在创建迭代器之后的任何时候对映射进行结构修改，除了通过迭代器自己的remove方法之外，迭代器将抛出ConcurrentModificationException。。 因此，在并发修改的情况下，迭代器快速而干净地失败，而不是在未来的未确定时间冒任意，非确定性行为的风险。

请注意，迭代器的快速失败行为无法得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬性保证。 失败快速迭代器会尽最大努力抛出`ConcurrentModificationException`。 因此，编写依赖于此异常的程序以确保其正确性是错误的：迭代器的快速失败行为应该仅用于检测错误。

### 字段 ### 

实施说明。

此映射通常用作binned（bucketed）哈希表，但是
当垃圾箱变得太大时，它们会变成垃圾箱
TreeNodes，每个都与其中的结构类似
java.util.TreeMap中。 大多数方法都尝试使用普通箱，但是
适用时中继到TreeNode方法（只需检查
节点的实例）。 可以遍历TreeNodes的bin
像其他人一样使用，但另外支持更快的查找
当人口过剩时。 但是，由于绝大多数的垃圾箱
正常使用不会人满，检查是否存在
在表格方法的过程中，树箱可能会被延迟。

树容器（即元素都是TreeNodes的容器）是
主要由hashCode命令，但在tie的情况下，如果两个
元素是相同的“C类实现Comparable <C>”，
然后使用他们的compareTo方法进行排序。 （我们
通过反射保守地检查泛型类型以进行验证
这 - 请参阅compareClassFor方法。 增加的复杂性
在提供最坏情况O（log n）时，树箱的价值是值得的
当键具有不同的哈希值或者具有不同的哈希值时
可订购的，因此，性能会优雅地降低
hashCode（）方法中的偶然或恶意用法
返回分布不均的值以及中的值
许多密钥共享一个hashCode，只要它们也是
可比。 （如果这些都不适用，我们可能会浪费一个
时间和空间两个因素相比，没有
注意事项。 但唯一已知的案例源于用户不佳
编程实践已经非常缓慢了
差别很小。）

因为TreeNodes大约是常规节点大小的两倍，所以我们
仅当垃圾箱包含足够的节点以保证使用时才使用它们
（见TREEIFY_THRESHOLD）。 当它们变得太小时（由于
移除或调整大小）它们被转换回普通箱。 在
使用分布均匀的用户hashCodes，树箱是
很少用。 理想情况下，在随机hashCodes下，频率为
箱中的节点遵循泊松分布带有
默认大小调整的平均参数约为0.5
阈值为0.75，虽然因为有很大的差异
调整粒度。 忽略方差，预期
列表大小k的出现是（exp（-0.5）pow（0.5，k）/
阶乘（K））。 第一个值是：

0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
more: less than 1 in ten million

树bin的根通常是它的第一个节点。 然而，
有时（目前仅在Iterator.remove上），根可能
在其他地方，但可以在父链接后恢复
（方法TreeNode.root（））。

所有适用的内部方法都接受哈希码作为
参数（通常由公共方法提供），允许
他们互相调用而不重新计算用户hashCodes。
大多数内部方法也接受“制表符”参数，即
通常是当前表，但可能是新的或旧的
调整大小或转换。

当bin列表被树化，拆分或未解析时，我们会保留
它们处于相同的相对访问/遍历顺序（即字段）
Node.next）以更好地保留局部性，并略微保持局部性
简化对调用的拆分和遍历的处理
iterator.remove。 在插入时使用比较器时，要保持一个
总排序（或尽可能接近）
重新平衡，我们比较类和identityHashCodes为
搭配断路器。

普通vs树模式之间的使用和转换是
复杂的子类LinkedHashMap的存在。 看到
下面是定义为在插入时调用的钩子方法，
删除和访问允许LinkedHashMap内部
否则保持独立于这些机制。 （这也是
要求将映射实例传递给某些实用程序方法
这可能会创建新的节点。）

类似于并发编程的基于SSA的编码风格有所帮助
避免在所有扭曲的指针操作中出现锯齿错误。



```
/**
 * 默认初始容量 - 必须是2的幂。
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
```

```
/**
 * 如果具有参数的任一构造函数隐式指定较高值，则使用最大容量。
 * 2 的次幂 <= 1<<30.
 */
static final int MAXIMUM_CAPACITY = 1 << 30;
```

```
/**
 * 在构造函数中未指定时使用的加载因子。
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

```
/**
  *bin计数阈值，用于使用树而不是bin的列表. 
  *将元素添加到具有至少这么多节点的bin时，bin被转换为树。
  *该值必须大于2并且应该至少为8以与树木移除中的假设相关联，以便在收缩时转换   *回普通箱。
  */
static final int TREEIFY_THRESHOLD = 8;
```

```
/**
 * 用于在调整大小操作期间解除（拆分）bin的bin计数阈值。
 * 应小于TREEIFY_THRESHOLD，最多6个与去除时的收缩检测啮合。
 */
static final int UNTREEIFY_THRESHOLD = 6;
```

```
/**
 * 容器可以树化的最小表容量。
 *（否则，如果bin中的节点太多，则会调整表的大小。）
 *应该至少4 * TREEIFY_THRESHOLD以避免
 *调整大小和树化阈值之间关系的冲突。
 */
static final int MIN_TREEIFY_CAPACITY = 64;
```