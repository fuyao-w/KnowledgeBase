**GO**



垃圾回收

常见的垃圾回收算法：

- 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减一，当引用计数为0时回收该对象。

- - 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阈值时才回收。
  - 缺点：不能很好的处理循环引用，而且实时的维护引用计数，也有一定的代价。
  - 代表语言：Python、PHP、Swift

- 标记-清除：从根变量遍历所有引用的对象，引用对象标记为”被引用“，没有被标记的进行回收。

- - 优点：解决了引用计数的缺点
  - 缺点：需要STW（Stop The World），就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine，这回导致程序短时间的暂停。
  - 代表语言：Go（三色标记法）

- 分代收集：按照对象生命周期的长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率。

- - 优点：回收性能好
  - 缺点：回收算法复杂
  - 代表语言：Java



Go 使用标记清除算法进行垃圾回收工作， 从根对象遍历所有的引用对象，并将其标记为被引用。最后将没有被引用的进行回收

根对象包括三种

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。（堆外运行时数据结构中的任何堆指针）



**Go**垃圾回收的三色标记法 https://mp.weixin.qq.com/s/Ujqr-Y_NVG6vwH4UtkEmKw

三色标记法只是为了描述方便抽象出来的一种说法，实际上对象并没有颜色之分。这里的三色对应了垃圾回收过程中对象的三种状态：

- 灰色：对象还在标记队列中等待，没扫描完毕
- 黑色：对象已被标记，gcmarkBits对应的位为1（对象不会在本次GC中被清理）
- 白色：对象未被标记，gcmarkBits对应的位为0（对象将会在本次GC中被清理）





**GC 过程中的几个阶段：（CMS 并发标记清除）**

涉及到两次stop the world

**1.stop the world**

  修改 **GC** 状态字段到 **_GCmark** ，开启写屏障，开启协助线程（mutator assist gc 期间运行的线程成为 mutator）， 最后将所有的 根 加入标记队列

 **start the world**



**2.**开始并发标记扫描

  **GC** 线程和辅助**GC** 开始与应用程序并发的扫描。此时如果有新创建或修改的指针则通过写屏障将其加入标记队列（标记为灰色），新创建的对象直接标记为黑色。**GC** 会扫描到所有的堆栈、全局变量、或者堆外的运行时结构中保存的指针（寄存器），扫描栈的时候也会暂停当前**Goroutine**

重复扫描过程直到将标记队列里所有的对象排空，此时所有的对象都被扫描过一遍了。



另外如果此时有新**goroutine** 申请内存，并且此时**GC** 压力较大，那么它需要进行辅助 **GC** 的工作。



**3.stop the world**

关闭辅助 **gc** 、禁用写屏障 、进行一些线程缓存的清理工作

**start the world**



**4.**后台异步清理就可以了









版本二

1. 清理终止阶段；

2. 1. 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
   2. 扫描任何未扫描的跨度。如果在预期时间之前强制执行此 GC 循环，则只会有未扫描的跨度。

3. 标记阶段；

4. 1. 通过将 gcphase 设置为 _GCmark（来自 _GCoff）、启用写屏障、启用 mutator 辅助以及将根标记作业排入队列，为标记阶段做好准备。在所有 P 都启用写屏障之前，不能扫描任何对象，这是使用 STW 完成的。
   2. 开始世界。从这一点来看，GC 工作由调度程序启动的标记工作 worker 完成，并由作为分配的一部分执行的协助完成。通过写入屏障将被修改的和新创建的指针标记为灰色（有关详细信息，请参阅 mbarrier.go）。新分配的对象立即标记为黑色
   3. GC 执行根标记作业。这包括扫描所有堆栈、对所有全局变量进行着色以及对堆外运行时数据结构中的任何堆指针进行着色。扫描堆栈会停止一个 goroutine，遮蔽在其堆栈上找到的任何指针，然后恢复 goroutine。
   4. GC 排空灰色对象的工作队列，将每个灰色对象扫描为黑色并将对象中找到的所有指针着色（这反过来可能会将这些指针添加到工作队列中）。
   5. 由于 GC 工作分布在本地缓存中，因此 GC 使用分布式终止算法来检测何时不再有根标记作业或灰色对象（请参阅 gcMarkDone）。此时，GC 过渡到标记终止。

5. 标记终止阶段；

6. 1. 停止世界。
   2. 将 **gcphase** 设置为 **_GCmarktermination**，并禁用工人和辅助。。执行内务处理，如刷新 **mcaches**。

7. 清理阶段；

8. 1. 通过将 gcphase 设置为 _GCoff、设置扫描状态和禁用写屏障来准备扫描阶段。
   2. 开始世界。从这一点开始，新分配的对象是白色的，如有必要，在使用前分配扫描跨度。 
   3.  GC 在后台执行并发清除并响应分配。请参阅下面的说明。







垃圾回收优化

写屏障（**Write Barrier**）

前面说过STW目的是防止GC扫描时内存变化而停掉goroutine，而写屏障就是让goroutine与GC同时运行的手段。虽然写屏障不能完全消除STW，但是可以大大减少STW的时间。

写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记（灰色)，即本轮不回收，下次GC时再确定。

GC过程中新分配的内存会被立即标记（黑色），用的并不是写屏障技术，也即GC过程中分配的内存不会在本轮GC中回收。

辅助**GC**（**Mutator Assist**）

为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分的工作，这个机制叫做Mutator Assist。



**垃圾回收触发时机**

**1.**用户调用 **runtime.GC()**

**2.**内存分配量达到阈值出发**GC**（一般的时候是翻倍）

​	每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值则立即启动GC。

​	阈值 = 上次GC内存分配量 * 内存增长率

​	复制代码

​	内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC。

**3.**定期触发**GC**

默认情况下，最长2分钟触发一次GC，这个间隔在src/runtime/proc.go:forcegcperiod变量中被声明：

// forcegcperiod is the maximum time in nanoseconds between garbage

// collections. If we go this long without a garbage collection, one

// is forced to run.

//

// This is a variable for testing purposes. It normally doesn't change.

var forcegcperiod int64 = 2 * 60 * 1e9



**GC**性能优化

GC性能与对象数量负相关，对象越多GC性能越差，对程序影响越大。

所以GC性能优化的思路之一就是减少对象分配个数，比如对象复用或使用大对象组合多个小对象等等。

另外，由于内存逃逸现象，有些隐式的内存分配也会产生，也有可能成为GC的负担。

内存逃逸现象3.1：变量分配在栈上需要能在编译器确定它的作用域，否则就会被分配到堆上。而堆上动态分配内存比栈上静态分配内存开销大很多。

go通过go build -gcflags=m命令来观察变量逃逸情况4

更多逃逸场景：[逃逸场景](https://link.juejin.cn/?target=https%3A%2F%2Frainbowmango.gitbook.io%2Fgo%2Fchapter04%2F4.3-escape_analysis%233-tao-yi-chang-jing)

逃逸分析的作用：

1. 逃逸分析的好处是为了减少GC的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要GC标记清除。
2. 逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好（逃逸的局部变量会分配在堆上，而没有发生逃逸的则由编译器分配到栈上）
3. 同步消除，如果你定义的对象在方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行

逃逸总结

- 栈上分配内存比在堆中分配内存有更高的效率
- 栈上分配的内存不需要GC处理
- 堆上分配的内存使用完毕会交给GC处理
- 逃逸分析的目的是决定内存分配到堆还是栈
- 逃逸分析在编译阶段完成







**groutinue 什么时候会被挂起？**

**系统调用 、 chanel 阻塞 、time.sleep 、 mutex 被阻塞 、 waitGroup 、select**





**为什么要 stop the world**



- 分析工作必须在一个能确保一致性的快照中进行
- 如果出现分析过程中对象引用关系还在不断地变化，则分析结果的准确性无法保证。

举个例子，如果分析时判断该对象已经没有引用，而分析后下一秒该对象又有了引用，则gc时会将该对象清理，导致错误发生。