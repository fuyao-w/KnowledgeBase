Go GMP 模型

1.0 单线程

1.1 多线线程

1.2 加入 P

1.2 - 1.13 基于协作的抢占调度器 （运行系统调用、or 栈扩张的时候）

1.4 基于信号的抢占调度器





G 是goroutine

M 是操作系统线程

P 是 G 和M 的中间层，负责内容： 1.为线程的运行提供上下文环境，2.负责调度在M 上等待的G队列。通过P的调度，每个线程都可以执行多个 G，并且能在G 执行IO 操作的时候让出计算资源，提高利用率。





核心是两个G队列

1. 全局
2. P的私有 大小为 256 的环形链表



执行逻辑，一般P会和M1 绑定，然后找 G 执行（寻找逻辑为 1.本地3. 全局 ，2从其他的P偷，4 网络IO 5 休眠），如果G 有 系统调用，则P 会摘除当前M 1（保存了G 的上下文）然后找 其他M2 继续执行， M1 醒来后会找 原来的P ,找不到换一个P ,全局P都绑定M 则 M1 进行等待。



这里有两个点，一个就是 work-steal 机制，

另一个是hand-off机制，P会尽量找M去执行G







上述就是基础的GMP 模型

当前，Go 还有具体的调度策略：





go 抢占式调度

1. 基于协作：1.用户主动调用 runtine.Gosched() 2.函数执行前发生栈扩张的时候，判断抢占标记（栈底指针被赋予了一个非常大的值，代表抢占标记 ），系统监控异步触发， 或者GC 的时候，或者当前M 持有的锁数量为 0 的时候。
2. 基于信号 ：M 注册信号处理函数，调度线程发出信号，收到信号的线程会 在栈上插入抢占函数，然后运行，要是被抢占就让出去了



GO 如何处理网络IO

go 利用的操作系统底层的多路复用模型，并且是异步的，一般是由一个单独的线程不断轮询，网络线程会将准备好的G 封装上下文，然后放到可运行队列里面，G 有反向指针，尽量找到原来的 p 等待P的执行。