## redis ##

数据类型：

1. String
2. Hash
3. List
4. Set
5. Sort Set
6. Bitmaps
7. HyperLogLogs

## 使用Redis作为LRU缓存 

当Redis用作缓存时，通常可以让它在添加新数据时自动逐出旧数据。这种行为在开发人员社区中非常有名，因为它是流行的*memcached*系统的默认行为 。

LRU实际上只是支持的驱逐方法之一。此页面介绍了Redis `maxmemory`指令的更一般主题，该指令用于将内存使用限制为固定量，并且它还深入介绍了Redis使用的LRU算法，实际上是精确LRU的近似值。

从Redis 4.0版开始，引入了新的LFU（最不常用）驱逐策略。本文档的单独部分对此进行了介绍。



### Maxmemory配置指令

所述`maxmemory`配置指令，以便用于Redis的配置为使用的存储器的指定量的数据集。可以使用该`redis.conf`文件设置配置指令，或稍后在运行时使用[CONFIG SET](https://redis.io/commands/config-set)命令。

例如，为了配置100兆字节的内存限制，可以在`redis.conf`文件中使用以下指令。

```
maxmemory 100mb
```

设置`maxmemory`为零会导致无内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

达到指定的内存量时，可以在不同的行为中进行选择，称为**策略**。Redis可以只返回可能导致使用更多内存的命令的错误，或者它可以逐出旧数据以便每次添加新数据时返回到指定的限制。

### 驱逐政策

`maxmemory`使用`maxmemory-policy`配置指令配置达到限制时Redis遵循的确切行为。

可以使用以下政策：

1. **noeviction**：当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时返回错误（大多数写命令，但[DEL](https://redis.io/commands/del)和一些例外）。
2. **allkeys-lru**：首先尝试删除最近使用较少的（LRU）密钥来逐出密钥，以便为添加的新数据腾出空间。
3. **volatile-lru**：首先尝试删除最近使用较少的（LRU）密钥，但仅在具有**过期设置的**密钥中删除密钥，以便为添加的新数据腾出空间。
4. **allkeys-random**：**随机**逐出密钥，以便为添加的新数据腾出空间。
5. **volatile-random**：**随机**逐出密钥以便为添加的新数据腾出空间，但只驱逐带有**过期集的**密钥。
6. **volatile-ttl**：用**过期集**驱逐密钥，并尝试先用较短的生存时间（TTL）驱逐密钥，以便为添加的新数据腾出空间。

如果没有用于驱逐匹配先决条件的keys，则volatile-lru，volatile-random和volatile-ttl策略的行为类似于noeviction。

### 新的LFU模式

从Redis 4.0开始，可以使用新的[最少使用的逐出模式](http://antirez.com/news/109)。在某些情况下，此模式可能更好（提供更好的命中/未命中率），因为使用LFU Redis将尝试跟踪项目的访问频率，以便很少使用的项目被驱逐，而使用的项目通常具有更高的机会留在记忆中

如果您在LRU中考虑，最近访问但实际上几乎从未请求的项目将不会过期，因此风险是驱逐将来有更高机会被请求的密钥。LFU没有这个问题，并且通常应该更好地适应不同的访问模式。

要配置LFU模式，可以使用以下策略：

7. `volatile-lfu` 使用过期集在密钥中使用近似LFU进行驱逐。

8. `allkeys-lfu` 使用近似LFU逐出任何键。

## 缓存击穿问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库崩溃。

### 解决方案

- 布隆过滤器（推荐）

  > 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

- 将查询缓存

  > 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。

- 使用互斥锁排队

  > 业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。



## 缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

### 解决方案 ###

- 也是像解决缓存穿透一样加锁排队，实现同上;

- 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有再读B，并且更新A缓存和B缓存;

- 设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，酱紫可从一定程度上避免雪崩问题；

## 缓存预热

 缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

 缓存预热解决方案：

- 直接写个缓存刷新页面，上线时手工操作下
- 数据量不大，可以在项目启动的时候自动进行加载
- 定时刷新缓存