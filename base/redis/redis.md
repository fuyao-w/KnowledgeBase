# Redis

### 特性：

1. 速度快

- 所有的数据是存放在内存中的，是redis速度快的主要原因
- 采用C语言实现，执行速度相对更快
- 使用单线程，I/O 多路复用架构，预防了多线程可能产生竞争的问题
- 作者对于Redis源码精细打磨

2. 基于键值对的数据结构服务器

   Redis的值不仅可以是字符串，还可以是具体的数据结构。它主要提供了5中数据结构：string、hash、list、set、sort set，同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种数据结构，并随着LBS（Location Based Service）的不断发展，Redis 3.2版本中加入有关GEO（地理信息定位）的功能。

3. 丰富的功能

   除了5中数据结构，Redis还提供了许多额外的功能：

   - 提供了键过期功能，可以用来实现缓存。
   - 提供了发布订阅功能。可以用来实现消息系统。
   - 支持Lua脚本功能，可以利用Lua创造出新的Redis指令。
   - 提供了简单的事物功能，能在一定程度上保证事物特性。
   - 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传递到Redis，减少网络开销

4. 简单稳定

   - 源码很少，早期版本的代码只有2万行左右，3.0版本后由于添加了集群特性，代码增至5万行左右，相对于很多NoSql数据来说，代码量相对要少很多。
   - 使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。
   - Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖linevent这样的系统类库），自己实现了事件处理的相关功能。

5. 客户端语言多

   Redis提供了简单的TCP通信协议，很多变成语言都可以很方便的接入到Redis，几乎涵盖了主流的变成语言。

6. 持久化

   Redis提供了两种持久化方式：RDB和AOF，既可以用两种策略将内存的数据保存到硬盘中，这样就保证了数据的可持久性。

7. 主从复制

   Redis提供了主从复制功能，实现了多个相同数据的Redis数据副本，复制功能是分布式Redis的基础。

8. 高可用和分布式

   Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis节点的故障发现和故障自动转移。从3.0版本正式提供了分布式实现Redis Cluster，它是真正的分布式实现，提供了高可用、读写和容量的扩展性。

### 使用场景

1. 缓存

   Redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。

2. 排行榜系统（sortset）

   Redis提供了列表和有序集合数据结构，合理的使用这些数据结构可以很方便的构建各种排行榜系统。

3. 计数器应用（incrby）

   例如视频网站有播放数，电商网站有浏览数，为了保持数据的实时性，每一次播放课浏览都要做加1的操作，如果并发量很大，对于传统数据库是一个挑战。Redis天然支持计数功能切计数的性能非常好，可以说是计数器系统的重要选择。

4. 社交网络

   踩/赞、粉丝、共同好友/喜好、推动、下拉刷新等社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型输数据不太社和保存这种类型的数据，Redis 提供的数据结构可以相对比较容易地实现这些功能。

5. 消息队列系统(list)

   消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦，非实时业务削峰等特性。Redis提供了发布订阅功能个阻塞队列的可能，虽然和专业的消息队列比还不够强大，但是对于一般的消息队列功能基本可以满足。

### Redis不可以做什么

​       在数据规模和数据冷热的角度来进行分析。站在数据规模的角度看，数据可以分为大规模数据和小规模数据，我们知道Redis的数据 是存放在内存中的，如果数据量太大的话经济成太高。

​       站在数据冷热的角度看，数分为热数据和冷数据，热数据通常是指需要频繁操作的数据，反之为冷数据，例如对视频网站来说，视频基本信息基本上在各个业务线都是经常要操作的数据属于热数据，而客户观看记录不一定是经常需要访问的数据冷数据。如果将冷数据放在内存中，基本上是对于内存的浪费，但对于一些热数据来说，可以放Redis中加速读写，也可以减轻后端存储的负载。

数据结构类型：

1. String（动态简单字符串 sds ，二进制安全，可以高效地实现追加和长度计算） 
2. Hash（默认使用压缩列表，当有需要的时候，程序才会转换到字典）
3. List（双端链表和压缩链表）
4. Set（intset 或者 hashtable）
5. Sort Set(ziplist 或者跳表)
6. Bitmaps
7. HyperLogLogs
8. Streams(5.0 之后提供)

## 使用Redis作为LRU缓存 

当Redis用作缓存时，通常可以让它在添加新数据时自动逐出旧数据。这种行为在开发人员社区中非常有名，因为它是流行的*memcached*系统的默认行为 。

LRU实际上只是支持的驱逐方法之一。此页面介绍了Redis `maxmemory`指令的更一般主题，该指令用于将内存使用限制为固定量，并且它还深入介绍了Redis使用的LRU算法，实际上是精确LRU的近似值。

从Redis 4.0版开始，引入了新的LFU（最不常用）驱逐策略。本文档的单独部分对此进行了介绍。



### Maxmemory配置指令

所述`maxmemory`配置指令，以便用于Redis的配置为使用的存储器的指定量的数据集。可以使用该`redis.conf`文件设置配置指令，或稍后在运行时使用[CONFIG SET](https://redis.io/commands/config-set)命令。

例如，为了配置100兆字节的内存限制，可以在`redis.conf`文件中使用以下指令。

```
maxmemory 100mb
```

设置`maxmemory`为零会导致无内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

达到指定的内存量时，可以在不同的行为中进行选择，称为**策略**。Redis可以只返回可能导致使用更多内存的命令的错误，或者它可以逐出旧数据以便每次添加新数据时返回到指定的限制。

### 驱逐政策

`maxmemory`使用`maxmemory-policy`配置指令配置达到限制时Redis遵循的确切行为。

可以使用以下政策：

1. **noeviction**：当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时返回错误（大多数写命令，但[DEL](https://redis.io/commands/del)和一些例外）。
2. **allkeys-lru**：首先尝试删除最近使用较少的（LRU）密钥来逐出密钥，以便为添加的新数据腾出空间。
3. **volatile-lru**：首先尝试删除最近使用较少的（LRU）密钥，但仅在具有**过期设置的**密钥中删除密钥，以便为添加的新数据腾出空间。
4. **allkeys-random**：**随机**逐出密钥，以便为添加的新数据腾出空间。
5. **volatile-random**：**随机**逐出密钥以便为添加的新数据腾出空间，但只驱逐带有**过期集的**密钥。
6. **volatile-ttl**：用**过期集**驱逐密钥，并尝试先用较短的生存时间（TTL）驱逐密钥，以便为添加的新数据腾出空间。

如果没有用于驱逐匹配先决条件的keys，则volatile-lru，volatile-random和volatile-ttl策略的行为类似于noeviction。

LRU和最小TTL算法不是精确的算法，而是近似算法（为了节省内存），因此您可以调整它以获得速度或精度。 默认情况下，Redis将检查五个键并选择最近使用的键，您可以使用以下配置指令更改样本大小。`maxmemory-samples 5`
默认值为5会产生足够好的结果。 10近似非常接近真实的LRU但是花费更多的CPU。 3非常快但不是很准确。

### 新的LFU模式

从Redis 4.0开始，可以使用新的[最少使用的逐出模式](http://antirez.com/news/109)。在某些情况下，此模式可能更好（提供更好的命中/未命中率），因为使用LFU Redis将尝试跟踪项目的访问频率，以便很少使用的项目被驱逐，而使用的项目通常具有更高的机会留在内存中

如果您在LRU中考虑，最近访问但实际上几乎从未请求的项目将不会过期，因此风险是驱逐将来有更高机会被请求的密钥。LFU没有这个问题，并且通常应该更好地适应不同的访问模式。

要配置LFU模式，可以使用以下策略：

7. `volatile-lfu` 使用过期集在密钥中使用近似LFU进行驱逐。
8. `allkeys-lfu` 使用近似LFU逐出任何键。

## 持久化

Redis 支持RDB 和 AOF 两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失的问题，当下次重启时，利用之前持久化的文件即可实现数据恢复。

### 问题:当进行持久化的过程中子进程操作会影响父进程的执行吗？

答：不会，  在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。

Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实 现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。  

### RDB

RBD 持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB 持久化分为手动触发和自动触发。

#### 触发机制

手动触发分别对应 save 和 bgsave 命令：

* save 命令：阻塞当前 redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。运行save 命令对应的 Redis 日志如下：

  * DB save on disk

* bgsave 命令：Redis 进程执行fork 操作创建子进程，RDB 持久化由子进程负责，完成后自动结束。阻塞只发生在fork 阶段，一般时间很短。运行 bgsave 命令对应的Redis 日志如下：

  * Background saving statred by pid 3151
  * DB saved on disk
  * RDB : 0 MB of memory used by copy-on-writs
  * Background saving terminated with success

  显然 bgsave 命令是针对 save 阻塞问题做的优化。因此Redis 内部所有的涉及 RDB 的操作都采用了 bgsave 方式，而save 命令已经废弃。

除了执行命令手动触发之外，Redis 内部还存在自动触发 RDB 的持久化机制，例如一下场景：

1. 使用 save 相关配置，如 `save m n `。表示 m 秒内数据存在 n 次修改时，自动触发 save.。
2. 如果节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。
3. 执行 debug reload 命令重新加载 redis 时，也会自动触发 save 操作。
4. 默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。

#### 流程

1. 执行 bgsave 命令，Redis 父进程判断当前是否存在执行的子进程，如 RDB/AOF 子进程，如果存在则 bgsave 命令直接返回。
2. 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞，通过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一个fork 操作的耗时，单位为微秒。
3. 父进程 fork 完成后，bgsave 命令返回 `Background saving statred`信息并不再阻塞父进程，可以继续响应其他命令。
4. 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。
5. 进程发送信号给父进程表示完成，父进程跟新统计信息，具体见 info Persistence 下的 rdb_*  相关选项。

#### RDB文件的处理

**保存**： RBD 文件保存在 dir 配置指定的目录下，文件名通过 dbfilename 配置指定。可以通过执行 `config set dir {newdir}` 和 `config set dbfilename {newFileName}`运行期动态执行，当下次运行时 RDB 文件会保存到新目录。

**压缩**：Redis 默认采用 LZF 算法对生成的 RBD 文件做压缩处理，压缩后的文件远远小于内存大下，默认开启，可以通过参数`config set rfbcompression {yes|no}` 动态修改。

**校验**：如果 Redis 加载损坏的 RDB 文件时拒绝启动，并打印如下日志：

> Short read or OOM loading DB.Unrecoverable error,aborting now.

这时可以使用 Redis 提供的redis-check-dump 工具检测 RDB 文件并获取对应的错误报告。

### RDB 的优缺点

RDB 的优点：

* RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每 6 小时执行 bgsave 备份，并把 RDB 文件拷贝带远程机器或者文件系统中（如hdfs）,用于灾难恢复。
* Redis 加载恢复数据远远快于 AOF 的方式。

RDB 的缺点：

* RDB 方式数据没办法做到实时持久化。因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。
* RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个格式的 RDB 版本，存在老版本 Redis 服务无法兼容新版 RDB格式的问题。

针对 RDB 不适合实时持久化的问题，Redis 提供了 AOF 持久化方式来解决。

### AOF

AOF（append only file）持久化：以独立日志的方式每次记录写命令，重启时在重新执行AOF 文件中的命令达到恢复数据的目的。AOF 的主要作用是解决了数据持久化的实时性，目前已经是Redis 持久化的主流方式。



#### 使用AOF

开启 AOF 功能需要设置配置：`appendonly yes`，默认不开启。AOF 文件名通过 `appendfilename` 配置设置，默认文件名是`appendonly.aof `。保存路径同 RDB 持久化方式一致，通过 dir 配置指定。AOF 的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。

流程：

1. 所有的写入命令会追加到 aof_buf （缓冲区）中。
2. AOF 缓冲区根据对应的策略向硬盘做同步操作。
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
4. 当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。

#### 命令写入

AOF 命令写入的内容直接是文本协议格式。例如 set hello world 命令，在 AOF 缓冲区会会追加如下文本：

> 3\r\n$3\r\nest\r\n$5\nhello\r\n$5\r\nworld\r\n

疑惑：

1. AOF为什么直接采用文本协议格式？可能的理由如下：

   * 文本协议具有很好的兼容性。
   * 开启 AOF 后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理的开销。
   * 文本协议具有可读性，方便直接修改和处理。

2.  AOF 为什么把命令追加到 aof_buf 中?Redis 使用单线程响应命令，如果每次AOF 文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区中，还有另外一个好处，Redis 可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。


#### 文件同步

Redis 提供了多种 AOF 缓冲区同步文件策略，由参数`appendfsync` 控制

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| always   | 命令写入 aof_buf 后调用 fsync 操作同步到 AOF 文件，fsync 完成后线程返回 |
| everysec | 命令写入 aof_buf 后调用系统 write 操作，write 完成后线程返回。fsync 同步文件操作由专门线程每秒调用一次。 |
| no       | 命令写入 aof_buf 后调用 write 操作，不对AOF 文件做 fsync 同步，同步硬盘操作由操作系统负责，通常同步周期最长为 30 秒。 |

系统调用 write 和 fsync 说明：

* write 操作会出发延迟写（delay write）机制。 Linux 在内核提供页缓冲区用来提高硬盘I/O 性能。write 操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，例如：缓冲区页空间写满或达到热特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。
* fsync 针对单个文件操作（比如 AOF 文件），做强制硬盘同步，fsync 将阻塞直到硬盘写入后返回，保证了数据的持久化。
  * 配置为 always 时，每次写入都要同步AOF 文件，在一般的 SATA 硬盘上，Redis 只能支持大约几百 TPS 写入，显然跟Redis 高性能特性背道而驰，不建议配置。
  * 配置为 no ，由于操作系统每次同步AOF 文件的周期不可控，而且会加大每次同步硬盘的数据，虽然提高了性能，但数据安全性无法保证。
  * 配置为 everysec ，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1 秒的数据。

#### 重写机制

随着命令不断写入 AOF，文件会越来越大， 为了解决这个问题，Redis 引入 AOF 重写机制压缩文件体积。在子进程创建一个新的AOF 问价来代替原有的文件。

不过，使用子进程也带来一个问题，子进程在AOF 重写期间，主进程还需要继续处理命令，而新的命令可能对现有的命令进行更改，这会让当前数据库的数据和重写后的AOF 文件中的数据不一致。

为了解决这个问题，Redis 增加了一个AOF 重写缓存，这个缓存在 fork 出子进程之后开始启用，redis 主进程在接到新的写命令之后，除了要将这个写命令的协议内容追加到现有AOF 文件之外，还会追加到这个缓存中。

在AOF 重写完成后，将重写缓存中的内容写入到新的AOF 文件中，对新的AOF文件进行改名，覆盖原有的AOF 文件。

重写后 AOF 文件为什么可以变小？

1. 进程内已经超时的数据不在写入文件
2. 旧的 AOF 文件含有无效命令，如的del key1、serm keys、set a 111 等。重写使用进程内数据直接生成，这样新的 AOF 文件只保留最终数据的写入命令。
3. 多条写命令可以合并为一个，如： lpush list a、 lpush list b、 lpush list c 可以转化为 lpush list a b c 。为了防止单条命令过大造成客户端缓冲区溢出，对于 list、set、hash、zset 等类型操作，以64 个元素为界拆分为多条。
4. AOF 重写，降低了文件占用空间。除此之外，另一个目的是：更小的 AOF 文件可以更快地被 Redis 加载。

AOF 重写过程可以手动出发和自动出发：

* **手动触发**：直接调用 bgrewriteaof 命令。
* **自动触发**：根据 auto-aof-rewrite-size 和 auto-aof-rewrite-percetenage 参数确定自动触发时机。
  * auto-aof-rewrite-size ：表示运行 AOF 重写时文件最小体积，默认为64 MB。
  * auto-aof-rewrite-percetenage ：代表当前 AOF 重写时文件空间（aof_current_size）和上一次重写后AOF 文件空间（aof_base_size）的比值。

#### 执行过程

1. 执行 AOF 重写请求。
2. 如果当前进程正在执行 AOF重写，请求不执行并返回如下响应。

> ERROR Background append only file rewriting already in progress

3. 如果当前进程正在执行 bgsave 操作，重写命令演出到 bgsave 完成之后再执行，返回如下响应

> Background append only file rewriting scheduled

4. 父进程执行fork 创建子进程，开销等同于 bgsave 过程。

5. 主进程 fork 操作完成后，继续响应其他命令。所有修改命令依然写入 AOF 缓冲区并根根据 appendfsync 策略同步到硬盘，保证原有 AOF 机制正确性。

6. 由于 fork 操作运行写时复制技术，子进程只能共享 fork 操作时的内存数据。由于父进程依然响应命令，Redis 使用“AOF 重写缓冲区”，保存这部分新数据，防止新 AOF 文件生成期间丢失这部分数据。

7. 子进程根据内存快照，按照命令合并规则写入到新的 AOF 文件。每次批量写入硬盘数据量由配置 aof-reerite-incremental-fsync 控制，默认为 32MB，防止单词刷盘数据过多造成硬盘阻塞。

8. 新 AOF 文件写入完成后，子进程发送信号给父进程，父进程更新统计信息。

9. 父进程把 AOF 重写缓冲区的数据写入到新的 AOF 文件。

10. 使用新 AOF 文件替换老文件，完成 AOF 重写。

### 重启加载

AOF 和 RDB 文件都可以用于服务器重启时的数据恢复。如果开启了 AOF ，则优先使用。

### 文件校验

加载损坏的 AOF 文件时会拒绝启动，并打印如下日志：

> Bad file format reading the append only file:make a backup of your AOF file , then yse ./redis-check-aof --fix <filename>

AOF 文件可能存在结尾不完整的请款，比如机器突然掉电导致 AOF 文件尾部命令写入不全。Redis 为我们提供了 aof-load-truncated 配置来兼容这种情况，默认开启。加载 AOF 时，

> !!! waring : short read while loading the AOF fie !!!
>
> !!! Truncating the AOF at offset 397856725 !!!
>
> AOF loaded anyway beacuse aof-load-truncated is enabled





## 缓存击穿问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库崩溃。

### 解决方案

- 布隆过滤器（推荐）

  > 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

- 将查询缓存

  > 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。

- 使用互斥锁排队

  > 业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。



## 缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

### 解决方案 ###

- 也是像解决缓存穿透一样加锁排队，实现同上;

- 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有再读B，并且更新A缓存和B缓存;

- 设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，这样可从一定程度上避免雪崩问题；

## 缓存预热

缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

 缓存预热解决方案：

- 直接写个缓存刷新页面，上线时手工操作下
- 数据量不大，可以在项目启动的时候自动进行加载
- 定时刷新缓存

