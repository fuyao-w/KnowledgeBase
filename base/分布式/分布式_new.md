**微服务**



**网关（API Gateway）的设计要素**

- - 限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。
  - 缓存：数据缓存。
  - 日志：日志记录。
  - 监控：记录请求响应数据，api耗时分析，性能监控。
  - 鉴权：权限身份认证。
  - 灰度：线上灰度部署，可以减小风险。
  - 路由：路由是API网关很核心的模块功能，此模块实现根据请求，锁定目标微服务并将请求进行转发。

**网关和代理的区别**

代理是同协议的转发、网关一般是可以有协议的转化，比如前端HTTP请求转化为服务发现。并且网关还有，限流，监控，鉴权，路由等功能。



**ppc**



**熔断、限流是什么**

限流是下游调用量太大，为了保证自身服务可用性，限制请求速率，进行请求降级。目的是保护自己。

熔断是下游请求上游的失败次数太多，为了不给上游太大的请求压力，选择不请求而直接返回兜底数据。目的是保护上游。









**什么是 CAP 理论？**

CAP理论是分布式架构中重要理论

前提：描述系统的瞬时状态

一致性(Consistency) (所有节点在同一时间具有相同的数据)

可用性(Availability) (保证每个请求不管成功或者失败都有响应)

分区容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)



**CAP 中的 P 是什么意思？**



分区容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)

**为什么说分布式系统，只能在 C、A 中二选一？**

因为，在分布式系统内，P 是必然的发生的，不选 P，一旦发生分区错误，整个分布式系统就完全无法使用了，这是不符合实际需要的。所以，对于分布式系统，我们只能能考虑当发生分区错误时，如何选择一致性和可用性。





由于 CAP 是学术理论，并不是工程理论，它会舍弃很多现实世界的问题。比如网络的时长，比如节点内部的处理速度不一致，比如节点间存储方式和速度的不一致。它说的一致性就是客户端是否能拿到最新数据，它说的可用性就是允许客户端拿不到最新数据。而这些东西被工程师们的过多脑补，导致了文章和文章说法不一样，解析不一样，阐述背景不一样。







**BASE 理论：**

BASE 是 **Basically Available**（基本可用） 、**Soft-state**（软状态） 和 **Eventually Consistent**（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了对系统的要求。

基本思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性，也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据的不可用或者不一致时，仍需要保持系统整体 主要可用。

BASE 理论三要素

1. 基本可用： 基本可用是指分布式系统在出现不可预知故障的时，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： **①** 响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；**②** 系统功能上的损失：正常情况下，在一个电商网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；
2. 软状态： 软状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；
3. 最终一致性： 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。





**服务监控**

服务级别：CPU ，内存，负载，tcp 连接数、QPS、QPM、接口平均响应时间

数据库：CPU、内存、QPS、并发数、连接数、慢查询、死锁、主从延时

Rds: CPU、连接数、内存、QPS、平均响应时间（访问延时）、命中率、还有针对具体命令的监控





**设计模式**

六大原则：

1.开闭原则：对扩展开放，对修改关闭

2.里氏代换：任何基类可以出现的地方，子类也一定可以出现

3.最少知道：一个实体尽量少的与其他实体间发生相互作用

4.依赖倒转：依赖接口而不是依赖具体类

5.合成复用：尽量使用合成、聚合的方式而不是使用继承

6.接口隔离：隔离多个接口，而不是使用单个接口。降低类之间的耦合度。



常见设计模式

工厂模式：做一个 UI 根据不同平台创建不同的按钮，但是不在声明处做判断，而是通过工厂方法获取。后续增加平台类型只需要修改工厂方法就行。 问题：按钮必须都属于同一个接口

抽象工厂模式：工厂的工厂，比如 阿迪，耐克 都会生产鞋子、上衣。在工厂方法上再封装一封

单例模式：懒汉模式 sync.Once  恶汉模式直接声明常量



装饰器模式：在不修改原本类的基础上，通过继承的方法，为原本类增加更多的功能例如：游戏皮肤的加成效果

桥接模式：通过接口的替换，将不同 A1 A2 和 B1 B2 之间的组合拆分开，使得不用实现 4 个具体的组合类，而是在需要的地方自行组装。

代理模式：通过在实现相同接口的外部类中包装一相同类型的个成员变量，从而在真正实行逻辑前后扩展功能的效果。对外只通过一个类来调用处理。

观察者模式：在某一动作执行结束后，通知多个对其感兴趣的对象，需要他们实现相同的回调方法即可。

策略模式：方法里要执行不同的计算逻辑：其他的不变传递一个接口执行不同逻辑

模板模式： 有通用方法，让子类按规则去执行就可以啦



建造者模式：将复杂对象差分成多个简单的独立部分，通过组合创建出完整对象。