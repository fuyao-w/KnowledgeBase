### 进程和线程的区别

### 进程

进程最根本的属性是动态性和并发性。我们将进程定义为**程序在并发环境中的执行过程**，**进程是资源分配个调度的基本单位。**

作为资源分配的单位，一个进程有自己的地址空间，其中包括程序，数据、PCB及其他资源。作为调度执行的单位，一个进程在执行的过程中需要使用一个或多个程序；另外一个进程的执行过程会与其他进程夹在一起。操作系统根据进程的状态和调度优先级对就绪进程实施调度。

**进程**和**程序**有密切的关系，但有时两个完全不同的概念，他们在以下四个方面有重要区别：

1. 动态性

   程序是静态被动的概念，本身可以作为一种软件资源长期保存：而进程是程序的一次执行过程，是动态、主动的概念，有一定的生命期，会动态地产生和消亡。

2. 并发性

   传统进程是一个独立运行的单位，能与其他进程并发执行。进程是作为资源申请和调度单位存在的；而通常的程序是不能作为一个独立运行的单位而并发执行的。

3. 非对应性

   程序和进程无一一对应关系，一个程序可以被多个进程公用：一个进程再起活动中又可顺序地执行若干程序。

### 进程的同步和通信

由于进程具有动态性和并发性。由于各个进程对资源的共享以及为完成一项共同的任务需要彼此合作。变产生了相互制约的关系。如果不加约束就会产生混乱。所以进程在并发环境中是不安全的，需要有同步机制来保持进程的正常活动。

进程间的相互关系主要分为如下三种形式：

1. **互斥**：各个进程彼此不知道对方存在，逻辑上没有关系。由于竞争同一资源而彼此发生制约。

   实现机制：硬件解决办法：禁止中断、专用机器指令

   ​		软件解决办法：使用算法

2. **同步**：各个进程不知道对方的名字，但通过某些对象（如I/O 缓冲区）的共同存取来协同完成任务。

   同步工具：信号量：整形信号量、结构型信号量、二值信号量

3. **通信**：各个进程可以通过名字彼此之间直接进行通信，交换信息，合作完成一项工作。

   进程通信方式：共享存储器、消息传递（直接通信：将消息挂载接受进程的消息缓冲队列上，接受进程直接从缓冲队列中得到消息。间接通信：发送进程将消息发送到称为信箱的中间设施中，接受进程从信箱中读取消息）、管道文件方式：连接两个命令的一个打开文件。（linux 中的管道  `|`）

## 常见的通信方式（共享内存速度最快）：

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

几种方式的比较：

* 管道：速度慢，容量有限
* 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
* 信号量：不能传递复杂消息，只能用来同步
* 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。


### 线程

线程是进程中实施调度和分派的进本单位。

引入线程的好处：

1. 易与调度
2. 提高并发性
3. 开销少
4. 利于充分发挥多核处理器的功能

### 线程和进程的关系

1. 一个进程可以有多个线程，但至少有一个线程；并且，一个线程只能在一个进程地址空间内活动。
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3. 处理机分配给线程，即真正在处理机上运行的是线程。
4. 线程在执行过程中需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

###### 死锁

死锁：在一个进程集合中每个进程都在等待仅由该集合中的另一个进程才能引发的事件（一般是释放资源）而无限期地僵持下去的过程。死锁产生的根本原因是资源有限且操作不当。

### 死锁的条件

1. #### 互斥条件

   某个资源在一段时间内只能由一个进程占有，不能同时被两个以上的进程占有。必须在占有该资源的进程主动释放它后，其他进程才能占有该资源。这是资源本身的属性所决定的。

2. #### 占有且等待条件

   进程已经占有一个资源，但又申请新的资源。由于该资源已被另外一个进程占有，此时该进程阻塞。但是他在等待新资源时，仍继续占有已分到的资源。

3. #### 不可抢占条件

   一个进程所占有的资源在用完之前，其他进程不能强行夺走该资源，只能由该进程用完后主动释放。

4. #### 循环等待条件

   存在一个进程等待序列，形成了一个环。

### 处理死锁的方法

原则上讲，处理死锁的方法有一下三种：

1. 利用某些协议预防或避免死锁，保证系统不会进入死锁状态。
2. 允许系统进入死锁状态，然后设法发现并解除它。
3. 完全忽略这个问题，好像系统中从来也不会出现死锁。

### 死锁的预防

* 破坏互斥条件

  一般来说，使用否定互斥条件的办法是不能预防死锁的，因为某些资源的固有属性就是不可共享的。

* 破坏占有且等待条件

  为使系统从来不会出现“占有且等待条件”，需要保证一个无论什么时候都可以申请它没有占用的任何资源。

  一种办法是**预分资源策略**，即在一个进程开始执行之前就申请并分配到所需的全部资源。在实现时，一个进程申请资源的系统调用要先于其他的系统调用。这就是资源的**静态分配**。

  另一种办法是**“空手”申请资源策略**，即每个进程仅在它不占有资源时才可以申请资源。一个进程可能需要申请并使用某些资源，在他们申请另外附加资源之前，必须先释放当前分配到的全部资源。

* 破坏不可抢占条件

  可以采用隐式抢占方式，如果一个进程占有某些资源，他还要申请被别的进程占有的资源，该进程就一定处于等待状态。这时，该进程当前所占有的全部资源可被抢占。也就是说这些资源隐式地释放了，在该进程的资源申请表中加上刚才隐式释放的资源。仅当进程获得他被剥夺的资源和新申请的资源时，他才能重新启动。

  另一种方法是抢占等待者的资源。若一个进程申请某些资源，首先应检查他们是否可供使用。如果可用，就分给该进程；如果他们不可用，就要查看：他们是否已分给另外某个正等待附加资源的进程。如果该资源被其他没有申请资源的进程占有，那么申请进程必须等待。当该进程等待时，它的某些资源也可被抢占过去。仅当一个进程分到它所需的新资源并恢复他在等待期间被强占过去的所有资源的情况下，他才能重新启动。

* 破坏循环等待条件

  为了不出现循环等待的条件，一种方法是实行**资源有序分配**策略，即把全部资源事先按类编号，然后依序分配，使进程申请、占用资源时不会形成环路。

### 死锁的避免

1. 银行家算法
2. 资源分配图算法
3. 安全状态：当一个进程申请一个可用资源时，系统必须决定：是把该资源立即分给它，还是让该进程等待，仅当系统处于安全状态下才能申请。

### 调度

调度算法：

1. 先来先服务法（FCFS）
2. 短作业优先法(SJF)
3. 最短剩余时间优先法(SRTF)
4. 优先级法()
5. 轮转法(RR)
6. 多级队列法()
7. 多级反馈队列法(MFQ)
8. 高响应比优先法(HRRF)  响应比RR=w+s/s (w:进程等待处理机所用时间 s:进程要求服务的时间)
9. 公平共享法



### 存储管理

#### 页面置换算法

1. 先进先出法
2. 最佳置换法
3. 最近最少使用法
4. 第二次机会置换法
5. 时钟置换法
6. 最少使用置换法
7. 页面缓冲算法



