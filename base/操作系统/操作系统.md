### 进程和线程的区别

### 进程

进程最根本的属性是动态性和并发性。我们将进程定义为**程序在并发环境中的执行过程**，**进程是资源分配个调度的基本单位。**

作为资源分配的单位，一个进程有自己的地址空间，其中包括程序，数据、PCB及其他资源。作为调度执行的单位，一个进程在执行的过程中需要使用一个或多个程序；另外一个进程的执行过程会与其他进程夹在一起。操作系统根据进程的状态和调度优先级对就绪进程实施调度。

**进程**和**程序**有密切的关系，但有时两个完全不同的概念，他们在以下四个方面有重要区别：

1. 动态性

   程序是静态被动的概念，本身可以作为一种软件资源长期保存：而进程是程序的一次执行过程，是动态、主动的概念，有一定的生命期，会动态地产生和消亡。

2. 并发性

   传统进程是一个独立运行的单位，能与其他进程并发执行。进程是作为资源申请和调度单位存在的；而通常的程序是不能作为一个独立运行的单位而并发执行的。

3. 非对应性

   程序和进程无一一对应关系，一个程序可以被多个进程公用：一个进程再起活动中又可顺序地执行若干程序。

4. 异步性

   各个进程在并发执行的过程中会产生相互制约关系，造成各自前进速度的不可预测性。而程序本身是静态的，不存在这种异步特性。

### 进程的基本特征

1. 动态性

   进程是程序的执行过程，它有生、有亡、有活动、有停顿，可以处于不同的状态。

2. 并发性

   多个进程的实体能够存在于同一内存中，在一段时间内都得到运行。这样，使得一个进程的程序并发执行。各个进程向前推进的速度是不可预知的，即以异步方式运行，这就造成进程间的相互制约，使程序失去在线性。

3. 调度性

   进程是系统中申请资源的单位，也是被调度的单位。操作系统中有很多的调度程序他们根据各自的策略调度合适的进程，为其运行提供条件。

### 进程的基本状态

1. 运行状态
2. 就绪状态、
3. 阻塞状态

在很多系统中，又增加了两种基本进程状态，即

4. 新建状态

5. 终止状态

#### 进程状态的转换

1. 新建 → 就绪
2. 就绪 → 运行
3. 运行 → 阻塞
4. 阻塞 → 就绪
5. 运行 → 就绪
6. 运行 → 终止

#### 进程映像

进程的活动是通过在CPU上执行一系列程序和对应数据进行操作来体现的，因此程序和数据都是进程的实体。但这二者仅是静态的文本，没有反应其动态特性。为此，还需要有一个数据结构来描述进程当前的状态、本身的特性、对资源的占用及调度信息等。这种数据结构被称为进程控制块（PCB）。此外，程序的执行过程必须包含一个或多个栈，用来保存过程调用和相互传送参数的踪迹。

所以**进程映像**通常就由程序、数据集合、栈和PCB 等 4 部分组成。

#### 进程控制块的组成

**进程控制块（PCB）** 是进程组成中最关键的部分，其中含有进程的描述信息和控制信息，是进程动态特性的中反映，是系统对进程实施识别和控制的依据。总的来说，进程控制块一般应包括如下内容。

1. 进程名：唯一标识对应的一个标识符或数字。有的系统用进程标识符作为进程的外部标识，用进程标识号（PID，在一定数值范围内的进程编号）作为进程的内部表示。
2. 特征信息：包括是系统进程还是用户进程，进程实体是否常驻内存等信息。
3. 进程状态信息：表明该进程的执行状态，是运行态，就绪态，还是阻塞态。
4. 调度优先权：表示进程获取CPU 的优先级别。当多个就绪进程竞争CPU 的时候，系统一般让优先权高的先占用 CPU。
5. 通信信息:反映该进程去哪些进程有什么样的通信关系，如等待那个进程的信号等。
6. 现场保护区：当对应进程由于某种原因放弃使用CPU 时，需要把它的一部分与运行环境有关的信息保存起来，以便在重新获得 CPU 后恢复正常运行。通常被保护的内容有程序计数器，程序状态字，各工作寄存器的内容等。
7. 资源需求、分配和控制方面的信息：如进程所需要或占有的 I/O 设备、磁盘空间、数据区等。
8. 进程实体信息: 该进程的程序和数据的存储情况，在内存或外存的地址、大小等。
9. 族系关系：反映父子进程的隶属关系。
10. 其他信息：如文件信息、工作单元等。

作用：进程的动态、并发等特征是利用 PCB 表现出来的。若没有进程控制块、则多道程序中的程序（和数据）是无法实现并发的。PCB 是进程存在的唯一标识。

### 进程队列

系统中有许多进程。处于就绪态和处于阻塞态的进程可以分别有多个，而阻塞的原因有各不相同。为了对所有进程进行有效的管理，常将各个进程的PCB 用适当的方式组织起来。

1. 线性方式

   最简单，也最容易实现。

   问题：限定了系统中同时存在的进程的最大数目。当很多用户同时上机时，会造成无法为用户创建系进程的情况。更严重的缺点是，在执行 CPU 调度时，为选择合理的进程投入运行，经常要对整个表进行扫描，降低了效率。

2. 链接方式

   按照进程的不同状态，分别将他们的 PCB 放在不同的队列中。

   在现代 UNIX 系统中采用，按进程优先级的高低分成多个队列，具有同一优先级的进程其 PCB 排在同一个队列上。

3. 索引方式

   索引方式利用索引表加不同状态进程的 PCB 地址。就是说，系统建立几张索引表，个对应进程的不同状态，如就绪索引表、阻塞索引表。状态相同的进程的 PCB 组织在同一索引表中，每个索引表目中存放一个 PCB 地址。各索引表在内存的起始地址放在专用的指针单元中

### 进程管理

#### 进程图

**进程图**是描述进程族关系的有向树。在系统中，众多进程之间存在着族系关系：由父进程创建子进程。从而形成一棵树形成进程族系关系图。

在开机时，首先引导（Boot） 操作系统，由引导程序将操作系统从硬盘装入内存；之后生成第一个进程（UNIX 系统中称作 0 号进程），由它创建1号进程以及其他核心进程；1号进程又为每个终端创建命令解释进程(shell 进程)；用户输入命令后又创建若干进程。这样便形成了一课进程树。树的跟节点是所有进程的祖先。上一个节点对应的进程是下一层节点对应的父进程。

创建进程步骤：

1. 申请一个空闲的 PCB ：从系统的 PCB 表中找出一个空间的 PCB 项，并制定唯一的进程标识号 PID（即进程内部名）

2. 为进程分配资源：根据调用者提供的所需内存的大小，为新进程分配必要的内存空间，存放其程序和数据及工作区。

3. 将进程的PCB 初始化:根据调用者提供的参数，将新进程的 PCB 初始化。这些参数包括新进程名（外部表示符）、父进程标识符、处理机初始状态、进程优先级、本进程开始地址等。一般将新进程状态设置为就绪状态。

4. 将新进程加入到就绪队列中：一个进程派生新的进程后，有两种可能的执行方式：

   1. 子进程和父进程并发执行
   2. 父进程等待他的某个或全部子进程终止

   建立子进程的地址空间也有两种可能的方式

   1. 子进程复制父进程的地址空间
   2. 把程序装入子进程的地址空间



### 进程的同步和通信

由于进程具有动态性和并发性。由于各个进程对资源的共享以及为完成一项共同的任务需要彼此合作。变产生了相互制约的关系。如果不加约束就会产生混乱。所以进程在并发环境中是不安全的，需要有同步机制来保持进程的正常活动。

进程间的相互关系主要分为如下三种形式：

1. **互斥**：各个进程彼此不知道对方存在，逻辑上没有关系。由于竞争同一资源而彼此发生制约。

   实现机制：硬件解决办法：禁止中断、专用机器指令

   ​		软件解决办法：使用算法

2. **同步**：各个进程不知道对方的名字，但通过某些对象（如I/O 缓冲区）的共同存取来协同完成任务。

   同步工具：信号量：整形信号量、结构型信号量、二值信号量

3. **通信**：各个进程可以通过名字彼此之间直接进行通信，交换信息，合作完成一项工作。

   进程通信方式：共享存储器、消息传递（直接通信：将消息挂载接受进程的消息缓冲队列上，接受进程直接从缓冲队列中得到消息。间接通信：发送进程将消息发送到称为信箱的中间设施中，接受进程从信箱中读取消息）、管道文件方式：连接两个命令的一个打开文件。（linux 中的管道  `|`）

## 常见的通信方式（共享内存速度最快）：

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

几种方式的比较：

* 管道：速度慢，容量有限
* 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
* 信号量：不能传递复杂消息，只能用来同步
* 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。


### 线程

线程是进程中实施调度和分派的进本单位。

线程有时也成为轻载进程（LWP）。每个线程有一个 thread 结构，即线程控制块，用于保存自己的私有信息，主要由一下4个基本部分组成：

1. 一个唯一的线程标识符
2. 描述处理器工作情况的一组寄存器（如程序计数器、状态寄存器、通用寄存器等）的内容。
3. 每个 thread 结构有两个栈指针。一个执行核心栈，一个指向用户栈。当用户线程转变到核心态的方式下运行时，就使用核心栈；当线程在用户状态下执行只，就是用自己的用户栈。
4. 一个私有存储区，存放现场保护信息和其他与该线程相关的统计信息等。

线程必须在某个进程内执行。它所需的其他资源，如代码段、数据段、打开的文件和信号等，都由它所属的进程拥有。即操作系统分配这些资源时以进程为单位。

一个进程可以包含一个线程或多个线程。这些线程除自己私有的少量资源外，要共享所属进程的全部资源。

引入线程的好处：

1. 易与调度
2. 提高并发性
3. 开销少
4. 利于充分发挥多核处理器的功能

### 线程和进程的关系

1. 一个进程可以有多个线程，但至少有一个线程；并且，一个线程只能在一个进程地址空间内活动。
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3. 处理机分配给线程，即真正在处理机上运行的是线程。
4. 线程在执行过程中需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

#### 线程的实现

在用户空间实现：

优点：

1. 线程切换速度快，无需进行系统调度。
2. 调度算法可以是程序专用的。允许程序自己设计。
3. 用户级线程可以运行在任何操作系统上，包括不支持线程机制的操作系统。

缺点：

1. 系统调用的阻塞问题。在典型的操作系统中，多数操作系统的调用是阻塞式的。当一个线程在执行系统调用时，不进它自己被阻塞，而且在同一个进程内的所有线程都被阻塞。
2. 在单纯的用户级别线程中，多线程应用程序不具有多处理器的优点。因为核心只为每个进程每次分配一个处理器，每次只有一个该进程的线程得以执行。

在核心空间实现

核心知道线程的存在，并对他们实施管理。线程表不在每个进程的空间中，而是在核心空间中。线程表中记载系统中搜有线程的情况。当一个线程想创建一个线程或删除一个现有线程时，必须执行系统调用，后者通过更新核心空间的线程表来完成上述工作。线程表中的信息与用户级线程相同。另外核心空间除了保存一个线程表外，还保存一个传统的进程表，其中记载系统中所有的进程信息。

在核心级线程方式下，将进程作为一个整体来管理，它的有关信息由核心保管。核心调度时以线程为基本单位，这种方式客服了用户级线程方式的两个缺陷：

1. 在多处理器系统中，核心可以同时调度同一个进程的多个线程
2. 如果一个进程的某个线程阻塞了，核心可以调度同一进程的另外一个线程。核心级线程方式的一个优点是，核心线程本身也可以是多线程的。

缺点：

1. 控制转移开销大。在同一个进程中，从一个线程切换到另一个线程时，需要将模式切换到核心态。

有些操作系统把两者结合在一起，从而取长补短。同一个进程的多个用户级线程位于某个或全部核心线程之上。

在组合方式中，核心只知道核心级线程，也只对他们实施调度。某些核心级线程对应多个用户级线程。这些用户级线程的创建，删除和调度完全在用户空间中进行。

利用组合方式，同一个进程内的多个线程合一在多个处理器上并行运行，且阻塞式的系统调用不必将整个进程阻塞。

### 死锁

死锁：在一个进程集合中每个进程都在等待仅由该集合中的另一个进程才能引发的事件（一般是释放资源）而无限期地僵持下去的过程。死锁产生的根本原因是资源有限且操作不当。

### 死锁的条件

1. #### 互斥条件

   某个资源在一段时间内只能由一个进程占有，不能同时被两个以上的进程占有。必须在占有该资源的进程主动释放它后，其他进程才能占有该资源。这是资源本身的属性所决定的。

2. #### 占有且等待条件

   进程已经占有一个资源，但又申请新的资源。由于该资源已被另外一个进程占有，此时该进程阻塞。但是他在等待新资源时，仍继续占有已分到的资源。

3. #### 不可抢占条件

   一个进程所占有的资源在用完之前，其他进程不能强行夺走该资源，只能由该进程用完后主动释放。

4. #### 循环等待条件

   存在一个进程等待序列，形成了一个环。

### 处理死锁的方法

原则上讲，处理死锁的方法有一下三种：

1. 利用某些协议预防或避免死锁，保证系统不会进入死锁状态。
2. 允许系统进入死锁状态，然后设法发现并解除它。
3. 完全忽略这个问题，好像系统中从来也不会出现死锁。

### 死锁的预防

* 破坏互斥条件

  一般来说，使用否定互斥条件的办法是不能预防死锁的，因为某些资源的固有属性就是不可共享的。

* 破坏占有且等待条件

  为使系统从来不会出现“占有且等待条件”，需要保证一个无论什么时候都可以申请它没有占用的任何资源。

  一种办法是**预分资源策略**，即在一个进程开始执行之前就申请并分配到所需的全部资源。在实现时，一个进程申请资源的系统调用要先于其他的系统调用。这就是资源的**静态分配**。

  另一种办法是**“空手”申请资源策略**，即每个进程仅在它不占有资源时才可以申请资源。一个进程可能需要申请并使用某些资源，在他们申请另外附加资源之前，必须先释放当前分配到的全部资源。

* 破坏不可抢占条件

  可以采用隐式抢占方式，如果一个进程占有某些资源，他还要申请被别的进程占有的资源，该进程就一定处于等待状态。这时，该进程当前所占有的全部资源可被抢占。也就是说这些资源隐式地释放了，在该进程的资源申请表中加上刚才隐式释放的资源。仅当进程获得他被剥夺的资源和新申请的资源时，他才能重新启动。

  另一种方法是抢占等待者的资源。若一个进程申请某些资源，首先应检查他们是否可供使用。如果可用，就分给该进程；如果他们不可用，就要查看：他们是否已分给另外某个正等待附加资源的进程。如果该资源被其他没有申请资源的进程占有，那么申请进程必须等待。当该进程等待时，它的某些资源也可被抢占过去。仅当一个进程分到它所需的新资源并恢复他在等待期间被强占过去的所有资源的情况下，他才能重新启动。

* 破坏循环等待条件

  为了不出现循环等待的条件，一种方法是实行**资源有序分配**策略，即把全部资源事先按类编号，然后依序分配，使进程申请、占用资源时不会形成环路。

### 死锁的避免

1. 银行家算法
2. 资源分配图算法
3. 安全状态：当一个进程申请一个可用资源时，系统必须决定：是把该资源立即分给它，还是让该进程等待，仅当系统处于安全状态下才能申请。

### 调度

调度算法：

1. 先来先服务法（FCFS）
2. 短作业优先法(SJF)
3. 最短剩余时间优先法(SRTF)
4. 优先级法()
5. 轮转法(RR)
6. 多级队列法()
7. 多级反馈队列法(MFQ)
8. 高响应比优先法(HRRF)  响应比RR=w+s/s (w:进程等待处理机所用时间 s:进程要求服务的时间)
9. 公平共享法



### 存储管理

#### 页面置换算法

1. 先进先出法
2. 最佳置换法
3. 最近最少使用法
4. 第二次机会置换法
5. 时钟置换法
6. 最少使用置换法
7. 页面缓冲算法



