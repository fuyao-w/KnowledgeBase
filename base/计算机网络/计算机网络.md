### OSI  七层网络协议（五层协议没有 会话层、表示层）

### 应用层

与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的[代码](https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81)，从事字[处理](https://baike.baidu.com/item/%E5%A4%84%E7%90%86)工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字[处理器](https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8)的程序就需要实现OSI的第7层。示例：[TELNET](https://baike.baidu.com/item/TELNET/810597)，[HTTP](https://baike.baidu.com/item/HTTP/243074)，[FTP](https://baike.baidu.com/item/FTP/13839)，[NFS](https://baike.baidu.com/item/NFS/812203)，[SMTP](https://baike.baidu.com/item/SMTP/175887)等。

### 表示层

这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的[字符集](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86)转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。

### 会话层

它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的[数据](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370)，则用数据代表表示层。示例：RPC，SQL等。

### 传输层

这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)上对不同应用的[数据流](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81)的输入进行复用，还包括对收到的顺序不对的[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)的重新排序功能。示例：[TCP](https://baike.baidu.com/item/TCP/33012)，[UDP](https://baike.baidu.com/item/UDP/571511)，[SPX](https://baike.baidu.com/item/SPX/610336)。

### 网络层

这层对端到端的包传输进行定义，它定义了能够标识所有结点的[逻辑地址](https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80)，还定义了[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)实现的方式和学习的方式。为了适应[最大传输单元](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83)长度小于包长度的[传输介质](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8)，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。

### 数据链路层

它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。

### 物理层

OSI的物理层规范是有关[传输介质](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8)的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧	q的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。

## TCP/IP 四层

应用层 (http)

传输层 （tcp udp）

网络层（IP 协议）

网络接口层

## 运输层的两个主要协议以及区别

TCP/IP 运输层的两个主要协议都是因特网的正式标准。

1. 用户数据报协议 UDP（User Dataptam Protocol）,传送UDP数据报
2. 传输控制协议 TCP(Transmission Control Protocol)，传送TCP报文段

### UDP

用户数据报协议UDP只在IP数据报服务上增加了很少的一点功能，复用和分用以及差错检测。

特点：

1. 无连接
2. 尽最大努力交付
3. 面向报文的
4. 没有拥塞控制
5. 支持一对一，一对多，多对一，多对多的交互通信。
6. 首部开销小（只有8字节）

### TCP

特点：

1. 面向连接的运输层协议
2. 每一条TCP 连接只能有两个端点（一对一），连接的端点叫做套接字(IP地址：端口号)
3. 提供可靠交付服务
4. 提供全双工通信
5. 面向字节流
6. 首部 20 字节。

#### 三次握手：

* Server 的TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程进入 LISTEN 状态，等待Client 的连接请求。
* 第一次握手，Client 的客服进程也是首先创建传输控制块TCB，然后向 SERVER 发送连接请求报文段，Client 将首部 SYN 标志位置为1，并为自己选择一个初始序号赋值给seq 代表本次发送字一个字节的序号，（SYN 同步位为1 时，不携带报文也要消耗掉一个序号），这时Client 进入 SYN-SENT (同步以发送)状态。
* 第二次握手，Server 收到请求报文后，如同意建立连接，则向 Client 发送确认。在报文段中 把 SYN 和 ACK 报文段都置为 1。确认号 ack = x+1，同时也为自己选择一个初始序号 seq = y。这时 Server 进入 SYN-REVD（同步以接收）状态。
* 第三次握手，Client 进程收到 Server的确认后，还要向B给出确认。确认报文段的 ACK 置1，确认号 ack = y+1，而自己的需要 seq = x+1。（ACK报文段可以携带数据。如果不携带数据则不消耗序号，下一个数据报文段的需要仍是 seq = x+1） 这是 TCP 连接已建立，Client 处于 ESTABLISH (已建立连接状态)。
* Server 收到 Client 确认后，也进入 ESTABLISH 状态。

为什么 A 还要发送一次确认呢？

答:为了防止已失效的连接请求报文段突然有传送到了 Server，如果使用两次连接，则Server只要发出确认， 就已经建立了连接，但是Client 确不知道，也不需要建立连接，这样就会浪费资源。

但是三次情况下，Client 如果没有发送确认，则Server 也不会与Client建立连接。

#### TCP 连接的释放

数据传输结束后，双方都可以释放连接。

* 现在Sever 和 Client 都处于ESTABLISH 状态。Client 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP 连接。Client 把连接释放报文段首部的 FIN 置 1。其需要 seq = u,它等于前面以传送过得数据的最后一个字节的序号加1。这是 Client 进入 FIN-WAIT-1 状态，等待 Server 的确认。（FIN 报文段必须消耗一个序号）。
* Server 收到连接释放报文段后立即发出确认，ACK 置 1，确认号是 ack = u+1，而这个报文段自己的序号是 seq v，Server 进入了 CLOSE-WAIT(关闭等待)状态，然后 Server 服务器进程应通知应用层进程，Client 到 Server 这方向的连接就释放了，这时的 TCP 连接处于半关闭状态。
* Client 收到来自于 Server 的确认后，就进入 FIN-WAIT-2 状态，等待 Server 发出的连接释放报文段。
* 如果 Server 准备关闭连接，其应用进程就通知 TCP 释放连接。这时B 发出的连接释放报文段必须使 FIN =1。并为 Server 的seq 置为 w(期间还发送了数据)。ack = u+1 ，这时 Server 进入 LAST-ACK （最后确认）状态。
* Client 在收到 Server 的连接释放报文段后，就必须对此发送确认。在确认报文段中 ACK 置为 1，确认好 ack = w+1,而自己的 seq = u+1。然后进入到 TIME-WAIT 状态，然后经过时间等待计时器设置的 2MSL（最长报文段寿命） 后，Client 才能进入到 CLOSED 状态。

为什么要经过2MSL 才能关闭呢？

答：为了保证 Client 发送的最后一个 ACK报文段能够到达 Server ，防止已失效的连接请求报文段出现在本连接中。

### TCP 可靠传输的原理

停止等待协议：每发送一个分组，就立即停止发送。等待对方的确认。

自动重传请求 ARQ：发送方超过一定的时间没有收到确认，就认为刚才发送的分组丢失了，需要重传前面发送过的分组。（超时重传机制）如果收到了重复的分组，要向对方重新发送确认分组，并且丢弃重复报文。

连续ARQ 协议：维护一个连续的发送窗口(滑动窗口)，位于发送窗口里面的分组发送后不需要等待对方确认。可以连续发送。 接收方一般都是采用累积确认的方式。对按需到达的最后一个分组发送确认。

### TCP 流量控制机制

几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复

慢开始和拥塞避免：

发送方维护一个拥塞窗口（cwnd）一般等于发送窗口

慢开始：（通常情况下，cwnd 刚开始设置为一个最大报文段 MSS，每收到对方得 确认报文后，就把 cwnd 增加多一个MSS，下面将的是书上的例子与此不同）发送方刚开始先把 cwnd 设置一个较小的数值。每经过一个传输轮次后 cwnd 大小加倍。

拥塞避免：为了避免 cwnd 增长过大引起网络阻塞，还需要设置一个慢开始门限 ssthresh。

用法：

当 cwnd < ssthresh 时，使用慢开始算法。

当 cwnd > ssthresh 时，停止使用慢开始算法而改变拥塞避免算法。

当 cwnd = ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算方法。

拥塞避免算法思路：初始阶段慢开始可以指数级增大。无论在慢开始阶段还是在拥塞避免阶段，只要判定发送放网络出现拥塞，就要把慢开始门限 ssthresh 设置为出现拥塞时的发送窗口的一半（但是大于1）。然后把 cwnd 重新设置为 1，让 cwnd 算法缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口增加一个MSS。

### 快重传和快恢复

快重传：接受方应及时发送失序报文的**确认**。如果发送方接受到连续三个重复确认，就应当立即重传失序报文。

快恢复：发送方连续收到三个重复确认是，就执行“乘法减小” 算法，把慢开始门限 ssthresh 减半，但不执行慢开始算法。而是把 cwnd 值设置为慢开始门限减半后的数值，然后执行拥塞避免算法（加法增大），使拥塞窗口现行增大。

注意：

1. 在发送完分组后，必须暂时保留已经发送的分组的副本。只有在收到确认后才可以清除暂时保留的副本。
2. 分组和确认分组都必须进行编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。
3. 超时计时器设置的重传时间应当比数据在分组的平均往返时间更长一些。

### HTTP 与 HTTPS 的区别

超文本传输协议 HTTP 被用于在 WEB 浏览器和服务器之间传送信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了传输报文，就可以直接读取信息。为了解决HTTP 协议的这一个缺陷，需要使用另一种协议：**安全套接字层超文本传输协议 HTTPS**，为了传输数据的安全，HTTPS 在HTTP的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。'

HTTP：是互联网上应用最为广泛的一种网络协议，HTTP 的工作方式是客户机与服务器之间的请求-应答协议。用于从 www 服务器传送超文本到本地的浏览器的传输协议，他可以使浏览器更加高效，使用网络传输更少。

HTTPS:是以安全为目标的HTTP 通道，在HTTP 下加入了 SSL 层，HTTPS 的安全基础是 SSL ，因此加密的详细内容就需要SSL。

HTTPS 协议的主要作用就可以分为两种，一种是建立一个信息安全通道，来保证数据传输的安全，另一种就是确认网站的真实性（需要证书）。

#### 主要区别：

1. https 协议需要申请证书，一般免费证书较少。因而需要一定费用。
2. HTTP 将信息明文传输，HTTPS 具有安全性的 SSL 加密传输协议。
3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样 HTTP 是 80，HTTPS 是 443。
4. 和HTTP 相比，HTTPS 通信会由于加密处理消耗更多的CPU 和内存资源。

#### HTTPS 工作原理

**1、客户端发起HTTPS请求**

这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

**2、服务端的配置**

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

**3、传送证书**

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

**4、客户端解析证书**

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

**5、传送加密信息**

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**6、服务段解密信息**

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

**7、传输加密后的信息**

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

**8、客户端解密信息**

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。



### HTTP 2.0

协议目标：

使用HTTPS 传输

二进制传输

异步连接多路复用；

头部压缩；

请求/响应管线化；

保持与HTTP 1.1[语义](https://baike.baidu.com/item/%E8%AF%AD%E4%B9%89)的向后兼容性也是该版本的一个关键目标。[SPDY](https://baike.baidu.com/item/SPDY)是一种[HTTP](https://baike.baidu.com/item/HTTP)兼容协议，由[Google](https://baike.baidu.com/item/Google)发起，[Chrome](https://baike.baidu.com/item/Chrome)、[Opera](https://baike.baidu.com/item/Opera/25140)、[Firefox](https://baike.baidu.com/item/Firefox)以及Amazon Silk等浏览器均已提供支持。HTTP实现的瓶颈之一是其并发要依赖于多重连接。HTTP管线化技术可以缓解这个问题，但也只能做到部分多路复用。此外，已经证实，由于存在中间干扰，浏览器无法采用管线化技术。SPDY在单个连接之上增加了一个帧层，用以多路复用多个并发流。帧层针对HTTP类的请求响应流进行了优化，因此运行在HTTP之上的应用，对应用开发者而言只要很小的修改甚至无需修改就可以运行在SPDY之上。SPDY对当前的HTTP协议有4个改进：

多路复用请求；

对请求划分优先级；

压缩HTTP头；

服务器推送流（即Server Push技术）；

SPDY试图保留HTTP的现有语义，所以[cookies](https://baike.baidu.com/item/cookies/187064)、ETags等特性都是可用的。 [3] 

### HTTP请求/响应报文结构

#### HTTP请求报文

一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1

方法字段就是HTTP使用的请求方法，比如常见的GET/POST

其中HTTP协议版本有两种：HTTP1.0/HTTP1.1 

3.空行

它的作用是通过一个空行，告诉服务器请求头部[到此为止](https://www.baidu.com/s?wd=%E5%88%B0%E6%AD%A4%E4%B8%BA%E6%AD%A2&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)。

4.请求数据

若方法字段是GET，则此项为空，没有数据

若方法字段是POST,则通常来说此处放置的就是要提交的数据

比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&password=123456，使用&来连接各个字段。

![](http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902554.png)



#### HTTP响应报文

同样的，HTTP响应报文也由三部分组成：响应行、响应头、响应体

1.响应行

响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK

其中协议版本HTTP/1.1或者HTTP/1.0，200就是它的状态码，OK则为它的描述。

2.响应头

响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。

3.响应体

响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。

### GET 和 POST 的区别

GET 和 POST 本质上是 TCP 连接。

GET: 向指定资源发出“显示” 请求。使用GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中。具有幂等性。

POST:向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

#### 基于浏览器和服务器的区别：

|                  | GET                                                          | POST                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |

有些浏览器在发送post请求时会先发送 header,服务器相应 100 continue，浏览器再发送 data，服务器相应 200 OK。