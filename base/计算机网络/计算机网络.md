### OSI  七层网络协议（五层协议没有 会话层、表示层）

### 应用层

与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的[代码](https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81)，从事字[处理](https://baike.baidu.com/item/%E5%A4%84%E7%90%86)工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字[处理器](https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8)的程序就需要实现OSI的第7层。示例：[TELNET](https://baike.baidu.com/item/TELNET/810597)，[HTTP](https://baike.baidu.com/item/HTTP/243074)，[FTP](https://baike.baidu.com/item/FTP/13839)，[NFS](https://baike.baidu.com/item/NFS/812203)，[SMTP](https://baike.baidu.com/item/SMTP/175887)等。

### 表示层

这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的[字符集](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86)转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。

### 会话层

它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的[数据](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370)，则用数据代表表示层。示例：RPC，SQL等。

### 传输层

这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)上对不同应用的[数据流](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81)的输入进行复用，还包括对收到的顺序不对的[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)的重新排序功能。示例：[TCP](https://baike.baidu.com/item/TCP/33012)，[UDP](https://baike.baidu.com/item/UDP/571511)，[SPX](https://baike.baidu.com/item/SPX/610336)。

### 网络层

这层对端到端的包传输进行定义，它定义了能够标识所有结点的[逻辑地址](https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80)，还定义了[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)实现的方式和学习的方式。为了适应[最大传输单元](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83)长度小于包长度的[传输介质](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8)，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。

### 数据链路层

它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。

### 物理层

OSI的物理层规范是有关[传输介质](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8)的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。

## TCP/IP 四层

应用层 (http)

传输层 （tcp udp）

网络层（IP 协议）

网络接口层

## 运输层的两个主要协议以及区别

TCP/IP 运输层的两个主要协议都是因特网的正式标准。

1. 用户数据报协议 UDP（User Dataptam Protocol）,传送UDP数据报
2. 传输控制协议 TCP(Transmission Control Protocol)，传送TCP报文段

### UDP

用户数据报协议UDP只在IP数据报服务上增加了很少的一点功能，复用和分用以及差错检测。

特点：

1. 无连接
2. 尽最大努力交付
3. 面向报文的
4. 没有拥塞控制
5. 支持一对一，一对多，多对一，多对多的交互通信。
6. 首部开销小（只有8字节）

### TCP

特点：

1. 面向连接的运输层协议
2. 每一条TCP 连接只能有两个端点（一对一），连接的端点叫做套接字(IP地址：端口号)
3. 提供可靠交付服务
4. 提供全双工通信
5. 面向字节流
6. 首部 20 字节。

#### 三次握手：

* Server 的TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程进入 LISTEN 状态，等待Client 的连接请求。
* 第一次握手，Client 的客服进程也是首先创建传输控制块TCB，然后向 SERVER 发送连接请求报文段，Client 将首部 SYN 标志位置为1，并为自己选择一个初始序号赋值给seq 代表本次发送字一个字节的序号，（SYN 同步位为1 时，不携带报文也要消耗掉一个序号），这是Client 进入 SYN-SENT (同步以发送)状态。
* 第二次握手，Server 收到请求报文后，如同意建立连接，则向 Client 发送确认。在报文段中 把 SYN 和 ACK 报文段都置为 1。确认号 ack = x+1，同时也为自己选择一个初始序号 seq = y。这是 Server 进入 SYN-REVD（同步以接收）状态。
* 第三次握手，Client 进程收到 Server的确认后，还要向B给出确认。确认报文段的 ACK 置1，确认号 ack = y+1，而自己的需要 seq = x+1。（ACK报文段可以携带数据。如果不携带数据则不消耗序号，下一个数据报文段的需要仍是 seq = x+1） 这是 TCP 连接已建立，Client 处于 ESTABLISH (已建立连接状态)。
* Server 收到 Client 确认后，也进入 ESTABLISH 状态。

为什么 A 还要发送一次确认呢？

答:为了防止已失效的连接请求报文段突然有传送到了 Server，如果使用两次连接，则Server只要发出确认， 就已经建立了连接，但是Client 确不知道，也不需要建立连接，这样就会浪费资源。

但是三次情况下，Client 如果没有发送确认，则Server 也不会与Client建立连接。

#### TCP 连接的释放

数据传输结束后，双方都可以释放连接。

* 现在Sever 和 Client 都处于ESTABLISH 状态。Client 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP 连接。Client 把连接释放报文段首部的 FIN 置 1。其需要 seq = u,它等于前面以传送过得数据的最后一个字节的序号加1。这是 Client 进入 FIN-WAIT-1 状态，等待 Server 的确认。（FIN 报文段必须消耗一个序号）。
* Server 收到连接释放报文段后立即发出确认，ACK 置 1，确认号是 ack = u+1，而这个报文段自己的序号是 seq v，Server 进入了 CLOSE-WAIT(关闭等待)状态，然后 Server 服务器进程应通知应用层进程，Client 到 Server 这方向的连接就释放了，这时的 TCP 连接处于半关闭状态。
* Client 收到来自于 Server 的确认后，就进入 FIN-WAIT-2 状态，等待 Server 发出的连接释放报文段。
* 如果 Server 准备关闭连接，其应用进程就通知 TCP 释放连接。这时B 发出的连接释放报文段必须使 FIN =1。并为 Server 的seq 置为 w(期间还发送了数据)。ack = u+1 ，这时 Server 进入 LAST-ACK （最后确认）状态。
* Client 在收到 Server 的连接释放报文段后，就必须对此发送确认。在确认报文段中 ACK 置为 1，确认好 ack = w+1,而自己的 seq = u+1。然后进入到 TIME-WAIT 状态，然后经过时间等待计时器设置的 2MSL（最长报文段寿命） 后，Client 才能进入到 CLISED 状态。

为什么要经过2MSL 才能关闭呢？

答：为了保证 Client 发送的最后一个 ACK报文段能够到达 Server ，防止已失效的连接请求报文段出现在本连接中。

### HTTP 与 HTTPS 的区别

超文本传输协议 HTTP 被用于在 WEB 浏览器和服务器之间传送信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了传输报文，就可以直接读取信息。为了解决HTTP 协议的这一个缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了传输数据的安全，HTTPS 在HTTP的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。'

HTTP：是互联网上应用最为广泛的一种网络协议，HTTP 的工作方式是客户机与服务器之间的请求-应答协议。用于从 www 服务器传送超文本到本地的浏览器的传输协议，他可以使浏览器更加高效，使用网络传输更少。

HTTPS:是以安全为目标的HTTP 通道，在HTTP 下加入了 SSL 层，HTTPS 的安全基础是 SSL ，因此加密的详细内容就需要SSL。

HTTPS 协议的主要作用就可以分为两种，一种是建立一个信息安全通道，来保证数据传输的安全，另一种就是确认网站的真实性（需要证书）。

#### 主要区别：

1. https 协议需要申请证书，一般免费证书较少。因而需要一定费用。
2. HTTP 将信息明文传输，HTTPS 具有安全性的 SSL 加密传输协议。
3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样 HTTP 是 80，HTTPS 是 443。
4. 和HTTP 相比，HTTPS 通信会由于加密处理消耗更多的CPU 和内存资源。

#### HTTPS 工作原理

**1、客户端发起HTTPS请求**

这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

**2、服务端的配置**

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

**3、传送证书**

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

**4、客户端解析证书**

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

**5、传送加密信息**

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**6、服务段解密信息**

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

**7、传输加密后的信息**

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

**8、客户端解密信息**

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。



### GET 和 POST 的区别

GET 和 POST 本质上是 TCP 连接。

GET: 向指定资源发出“显示” 请求。使用GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中。具有幂等性。

POST:向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

#### 基于浏览器和服务器的区别：

|                  | GET                                                          | POST                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |

有些浏览器在发送post请求时会先发送 header,服务器相应 100 continue，浏览器再发送 data，服务器相应 200 OK。