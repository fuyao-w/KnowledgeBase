**计算机网络**

**IP:**

**A** 类 **0xxxx**

**B** 类 **10xxx**

**C** 类 **110 xxx**

**D** 类 **1110 xxx**



子网掩码：解决 ***ip\*** 地址分配不均匀的问题 ，扩展了***<\***网络号、主机号的***>\***二级分类，通过借用主机号，表达出了一个子网号的概念

但是依旧是在基础的 ***abcd\*** 类网络上划分的



**CIDR : 无类别域间路由 (Classless Inter-Domain Routing)**

和子网掩码差不多，但是没有ip 分类的概念， 用[ip/数字]表示网络号与主机号。 多个网络可以组成超网。





**IPV4 和 IPV6 的区别**

性能

与IPv4相比，IPv6将地址长度从32位增加到了128位，可支持更多的地址需求。而且，IPv6地址的编码采用了类似于CIDR的分层分级结构，简化了路由，加快了路由速度。

**IP**报头

IPv4根据提供的IP选项，有20~60个字节的可变长度；而IPv6拥有40个字节的固定长度，相对于IPv4而言报头简单。此外，IPv4报头可能附带各种选项，但，IPv6报头没有选项，而是添加了附加的扩展报头（可选，其中包含了逐跳扩展、路由、分段和目标等），极大地减少了分组处理和报头带宽的开销。

网络安全

对于IPv4而言，互联网安全协议（IPsec）是可选的，但不一定是免费的，有的需要付费支持；但对于IPv6来说，互联网安全协议是必选项。此外，像身份验证、数据一致性和保密性的内容也加入到了IPv6中。由此说明，IPv6相对于IPv4来说，更加安全。

应用领域

如下图所示，从2009年到2019年通过IPv6访问Google的用户数占比小，且IPv6在早期阶段增长速度缓慢，这是为什么呢？究竟是什么原因导致IPv6的部署没有IPv4广泛呢？首先，IPv4在IPv6前面被提出，优先抢占了市场先机，而IPv6的部署是一个长期、循序渐进的过程。其次，在IPv6部署的前期，由于IPv6不够成熟，导致存在较多的问题，如，与现有的基础设施不兼容，无法从IPv4过渡到IPv6等。





**（NAT）Network Address Translation**

网络地址转换（英语：**N**etwork **A**ddress **T**ranslation，缩写：**NAT**；又称网络掩蔽、**IP**掩蔽）在[计算机网络](https://zh.wikipedia.org/wiki/計算機網絡)中是一种在IP[数据包](https://zh.wikipedia.org/wiki/封包)通过[路由器](https://zh.wikipedia.org/wiki/路由器)或[防火墙](https://zh.wikipedia.org/wiki/防火墙)时重写来源[IP地址](https://zh.wikipedia.org/wiki/IP地址)或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问[互联网](https://zh.wikipedia.org/wiki/網際網路)的[私有网络](https://zh.wikipedia.org/wiki/私有网络)中。它是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。



特殊应用场景：p2p 下载的时候 使用 udp 打洞



**ARP** 协议：地址解析协议。

**IP** 地址到 **MAC** 地址的映射，用于同一子网下的 **ip** 包交付





**BGP** 外部网关协议









**udp 首部格式：**

无连接、不可靠、尽最大努力交付、面向报文（一发就是一整个包）、无拥塞控制



源端口、目的端口

数据报长度、校验和

应用 ：**dns** 、流媒体协议 ，**DHCP** 、 一般的 **P2P** 连接

**Tcp 首部格式：**

面向连接、可靠交付、基于字节流的全双工通信



应用 **http \FTP\ssh\telnet** 



**(4** 字节为一行**)**

源端口 （2字节）、目的端口 （2字节）

序号 

确认号

数据偏移量(因为首部是可变长度，所以用它来确认用户数据的起始点) 2 字节、保留 4 + 6 rst+ack+fin+syn+psh+urg + 6 拥塞窗口

校验和 、 紧急指针



rst: 收到错误的报文段，回送表示强制关闭链接

ack : 接收方在请求中通过确认号，向发送方确认已经接受到的字节位置

fin : 连接终止请求

syn : 连接建立 同步请求

psh 立即交给应用层

urg 紧急数据要求立即发送 ,直到紧急指针的的偏移量发送完为止



psh 和urg 是从两端来表示出紧急数据的





**tcp 三次 握手**



首先 服务端 开启链接监听 处于 Listen 状态



客户端 发起链接请求，发送第一个请求包  其中 syn =1 并初始化 此次链接本方向的初始 序号 seq = u ，处于 同步已发送 SYN-SEND状态



服务器收到 请求： 发送回复包， 其中 syn =1 ACK= 1 ，并初始化此次链接本方向的初始序号 seq = v ，ack = u +1 处于 同步已接收

SYN_RECV 状态



客户端收到请求后最后一次回包： ACK = 1 其中 seq = u+1 ,ack = v+1 此次发送可携带正式报文段，不携带不消耗序号 ，链接建立完毕 处于 establish 状态



**为什么需要三次握手**

1. 三次握⼿手才可以阻止重复历史连接的初始化化造成混乱 (换个说法：防⽌止历史连接初始化了了连接)（主要原因，旧syn 先到 server ,client 会恢复 rst 的，就没啥异常影响了）
2. 三次握手 可以确认双方交换了序号，是后续正常通信的基础
3. 三次握⼿手才可以避免资源浪费（客户端收到一个 sync 就建立一个，会造成大量的无效请求）

**不使用「两次握手」和「四次握手」的原因：**

「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。





**tcp 四次挥手**



首先 客户端 主动关闭链接 发送 请求包 其中 FIN = 1 seq= u ack = w ， 处于 FIN_WAIT_1

服务端收到请求后 发送回复请求 ：ACK = 1 seq = w ack = u+1 处于 CLOSE_WAIT 并通知应用层对方方向连接已关闭



客户端收到请求后，进入 FIN_WAIT_2 状态，等待server 关闭连接





当服务端想关闭连接的时候 发送 FIN = 1 , seq = w  ack = u+1 处于 LAST_ACK 



客户端收到请求后 发 ACK=1 seq=u+1 seq = u+1 处于 TIME_WAIT 状态  



待等到 2 * MSL 报文段最大生存时间后 两端真正关闭连接 



**Time_wait 的时间为什么是 2 MSL**

msl 是 Maximum Segment Lifetime 意思是报文在网络中最大的生存时间，超过这时间后报文肯定已经在网络上消失了。

2 * msl 时间内可以进行两次报文的发送，在这个时间内如果被动关闭方（server）没收到对方的确认，可以有机会进行重发。接收方收到后可以重新回包重置等待时间。



client 收到fin 包后，回送 ACK 最多 1*MSL 被服务端收到，如果 server 收不到可以进行一次超时重传，又经过最多 1* MSL client 才能收到，这样一来一回的时间正好 2*MSL。





**Time_wait 的时间为什么不能是 3.4.5 MSl**

因为 2*MSL 可以保证一次FIN 报文丢失的情况，这种概率已经很小了，再花更大的代价去保证更多次数的丢失显然成本过高。





**MSL 与 TTL 的区别：**

MSL 的单位是时间，⽽而 TTL 是经过路路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间 ，以确保报⽂文已被⾃自然消亡



**为什么要等到 2\*MSL （为什么要有 time-awit 状态）** 

1. 为了让旧报文段在网络上彻底消失 。防止后续收到同一个socket 失效的报文段 ，造成数据冲突(client 立即关闭连接，重新建立新连接的case ，此时服务端还没收到 ack , 就又收到了建立链接或者数据传输的包)

![2022010501](/Users/wfy/Documents/KnowledgeBase/picture/network/2022010501.jpg)

2. 为了保证服务端能正常关闭，如果 ack 丢失则 服务端可以从新发送一次 FIN。



**为什么需要四次挥手**

因为tcp 链接可以处于半关闭状态，一方关闭 而另一方可以继续发送报文， 确认单方向关闭需要 一次 fin, 一次 ack

另一方需要关闭的时候也需要两次所以加起来为 4 次。	



**既然打开 net.ipv4.tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接，那为什么 Linux 默认是关闭状态呢？**

https://mp.weixin.qq.com/s/yIXihfy7lFajyeL6mXhU_Q

![2022010502](/Users/wfy/Documents/KnowledgeBase/picture/network/2022010502.jpg)



PAWS(Protect Against Wrapped Sequence numbers)一句话解释如下，后面会详细介绍

在高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped)

就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包！



tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：

- 历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。
- 如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;

虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。







- net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，内核会随机找一个 **time_wait** 状态超过 **1** 秒的连接给新的连接复用，所以该选项只适用于连接发起方。
- net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；

**Per-host 的 PWAS 机制**

那什么是 per-host 的 PAWS 机制呢？

前面我提到，开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS 机制。

**per-host** 是对「对端 **IP** 做 **PAWS** 检查」，而非对「IP + 端口」四元组做 PAWS 检查。



**Syn 包什么时候会被丢弃**

https://mp.weixin.qq.com/s/2xkYbczdHKgpUnicBw0pkA

1.半链接队列满了

2.在 NAT 网络的条件下。使用 tcp_reuse 设置的时候，由于



客户端 **B** 也通过 **NAT** 网关和服务器建立 **TCP** 连接，注意客户端 **A**  和 客户端 **B** 因为经过相同的 **NAT** 网关，所以是用相同的 **IP** 地址与服务端建立 **TCP** 连接，如果客户端 **B** 的 **timestamp** 比 客户端 **A** 的 **timestamp** 小，那么由于服务端的 **per-host** 的 **PAWS** 机制的作用，服务端就会丢弃客户端主机 **B** 发来的 **SYN** 包。



————————

**可靠传输：**

停止等待协议：每发送一个包，就等待对方回 ack 包。

自动重传请求：发送方超过一段时间没有收到确认，就认为刚才发送的分组丢失了，需要重传前面发送过的请求 。当接收端收到重复的请求的时候，需要将其丢弃，并立即发送 ack 包。



前提：

1. 发送方、接收方必须缓存已经收到的包，等到确认已接收 或者 向应用层提交后才可以丢弃
2. 需要维护一个序号机制，用于确认那些报文收到了，那些没收到
3. 发送方需要为每个报文段维护一个计时器



**流量控制：**



连续 ARQ 协议：（滑动窗口）维护一个可以连续发送的窗口，位于发送窗口里面的分组可以直接发送不需要等待确认。 接收方可以选择累积确认的方式，将连续收到的最新的 分组发送 ack 包。







**拥塞控制方法：**

慢开始，拥塞避免，快重传、快恢复



慢开始：维护一个 拥塞窗口 cwnd ,刚开始 发送一个 MSS 收到一个确认就将 cwnd 加倍。

拥塞避免：为了防止 cwnd 增长过大引起阻塞，需要维护一个慢开始门限 sstresh 。

用法是，当 cwnd < sstresh 慢开始

​		当 cwnd > sstresh 拥塞避免

​		当 cwnd = sstresh 都可

当判定网络出现拥塞（超时重传，快速确认）的时候 sstresh = cwnd/2 ,  cwnd = 1 ,开始执行拥塞避免方法，每过一轮 就将 cwnd +1 



快重传：当收到一个 失序报文的时候，立即连续发送 3 个 ack ，接收方收到连续确认立即发送对方未收到的报文。

快恢复： 当发送方收到连续三个 ack 后， 发送端将 stresh /= 2 ,cwnd= sstresh 执行拥塞避免算法





**SYNC 攻击**

SYN 攻击属于 DOS 攻击的一种，它利用TCP 协议缺陷，通过发送大量的半链接请求，耗费 CPU 和内存资源。

流程：服务端接受链接请求，然后将其加入 半连接队列，并回包 syn +ack 。当服务端未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未半连接队列删除。而正常的 syn 请求被丢弃，目标系统运行的缓慢，严重者引起网络堵塞甚至系统瘫痪。



防御方法：

1.增大半链接队列的长度(全连接也要增大)

要想增⼤大半连接队列列，我们得知不不能只单纯增⼤大 tcp_max_syn_backlog 的值，还需同时增⼤大 somaxconn 和 backlog，也就是增⼤大全连接队列列。

2.开启 tcp_synccookies 功能 https://blog.csdn.net/zgy666/article/details/106171059

3.减少(第二次握手) syn+ack 重传次数





**网络层次**



应用、（表示、会话）运输、网络、数据链路、物理



HTTP ：

方法 

GET\PUT\POST\HEAD\DELETE\TRACE\PATCH\CONNECT



POST 和 put 的区别



post 不幂等 put 幂等



PATCH 用法：通过 json-path协议，用一组操作命令部分更新资源



![Pasted Graphic_1.tiff](blob:file:///3d9a30b3-28b6-49e3-8fcd-d7162ddf0a6f)





**HTTP 状态码**

100 ： 已经收到请求，需要客户端继续发送请求  跨域的时候 使用



101 ：协议升级



200 ：处理成功

204 ：处理成功 没有返回值

206 : 部分请求 ，一般下载的时候用







300 ：多项选择，客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了

301 ：永久重定向

302 临时重定向

303 （查看其他位置） 临时重定向

304 if-match 内容没变可以继续使用缓存内容



400 请求错误，服务端无法处理

403 权限不足，需要认证

404 没找到对应的内容

405 方法禁用



500 服务端错误

501 尚未实施

502 网关转发后端服务器，但是服务器响应错误

503 服务不可用，暂时性

509 带宽不足



600 源站没返回 header 只有 content







**ping 命令原理（测试网络连通性）：**

使用网络层的 ICMP 协议

ICMP 协议分为两大类，差错报告报文、咨询报文

ping 使用 咨询报文的 回送请求、回送应答报文

请求和回送都附带一个时间戳 ，就可以知道访问到了那个IP 是否超时，和请求时间





**traceroute 报文（追踪到目标地址的路由器跳数）：**



原理：服务端收到无效的 udp 请求后必须发送 icmp 差错控制报文

客户端 先 通过 控制IP 报文 ttl =1 将请求发送给最近的路由器， 收到差错报文后，就知道该路由器的地址

然后 ttl+ 1 ,依次类推，知道直接到达目标服务端

就知道 中间经历了那些 路由器









**HTTP 请求格式**

方法，uri 、 版本

\r\n

header

\r\n

Body：



**HTTP 应答格式：**

版本 状态码 原因短语

\r\n

Header

\r\n

Body 



区分请求体： 长度（content-length） or trunk 通过空行





**http 1.1 的功能：**

使用 tcp 长链接方式改善了 1.0 短连接造成的性能开销

支持管道网络传输，只要第一个请求发送出去了，不必等其回来，就可以发送第二个请求出去，可以减少整体的相应时间

问题：

header 未压缩，首部信息越多延迟越大

服务器是按顺序相应，有队头阻塞问题

也没有请求优先级

请求只能从客户端开始，服务器只能被动相应





**http 2 特点**

可以直接代替 https 已经完成了请求加密

在协议改动上为：

1.首部压缩：HTTP/2 会压缩header ，原理类似 protobuf 给字段标号

2.二进制格式：header 和 body 都是二进制，最小单位称为帧，（头信息帧和数据帧）数据报可以通过帧乱序发送，为了解决消息组装的问题，帧必须有序号

3.多路复用：HTTP/2 可以在一个连接中并发进行多个请求或回应，而不用按顺序一一对应，也不需要排队等待，没有对头阻塞问题。（但是运输层面还是有的，停止等待协议）原理： 使用了流的概念，每个请求或相应都是一个 数据流，通过流ID 标识，客户端 奇数数， 服务端偶数 ，客户端可以执行流的优先级，并进行流量控制。

4.服务器推送：服务器可以在客户端请求的时候多推送一些内容



**HTTP2. 比 1.1 好在哪里**

1.压缩头部，可以更有效的利用带宽

2.二进制格式，计算机处理更快

3.多路复用可以使用相同数量的链接传输更多的数据，减少连接建立的开销

4.服务端推送也可以减少无效请求，尽量多的交换数据

5.流有优先级控制，可以在多路复用的基础上，根据优先级请求不同信息





**http3 特点：**

因为 tcp 协议出现拥塞的时候还是有运输层面的对头阻塞，所以使用 升级版本的 udp 协议（quic）代替



**https 特点：**

因为 http 是不安全的明文传输、敏感信息没有保护、不能验证对方的可靠性：

所以增加了加密功能，在 http 和 tcp 直接加入了 ssl/tls 层



加密方式：混合加密：原理：首先通过非对称加密，传递一个 pre master secret 作为对称加密的公钥，后面通过 pre master 对称加密交换信息

 

认证方式：通过证书来验证对方网站的可靠性，证书由 ca 认证机构颁发，一般在出厂内置到浏览器里。

通过ca 公钥，计算出对方提供的证书里的的基本信息是否和ca证书内容相符合。



连接步骤：

1. 客户端通过发送 client hello 报文开始 ssl 通信。报文中包含 ssl 版本+加密组件列表
2. server 回包选择一个加密组件 以及 ssl 版本 ，再发送 公钥和证书
3. client 发送 client key exchange 报文 ，通过公钥加密 pre master secret 随机密码串
4. 然后 client 发送 change cipher spec 报文 。表达后面用 pre master secert 通信
5. 然后server 收到后 回包 change cipher spec 报文后后面就正常加密通信

**证书验证过程**

证书，验证对方的可靠性，一般由ca 机构颁发，并在浏览器里直接内置了ca 颁发的证书，使用 ca 的公钥解密数字签名里的内容，看是否相等。



首先ca 机构把持有者的 公钥、用途，颁发者信息 计算出一个hash 值，然后通过私钥，加密hash 值，形成签名，附加在证书上



client 也计算一个 hash ,然后通过ca 公钥解密证书，判断 hash 值是否相等，并且验证证书内容



**Dns 域名解析服务：**

域名分类：根域名、顶级域名、权威域名

请求过程



先浏览器缓存

然后操作系统缓存

然后 hosts 文件



然后通过客户端和 isp 的本地 dns 服务器交互，本地请求 根、根回复本地 顶级的ip 、然后本地请求 顶级 、顶级回复 权威，本地请求权威、拿到真正地址并缓存



如果是个 cname 则还需要根据 映射找到 a name 的地址,然后重新 dns 



以上是递归方式：

迭代方式：就是 本机客户端每次自己去主动向各级 dns 服务器发起请求









 **CDN**

Content Delivery Network 内容分发网络，CDN 在不同的地方设置缓存服务器，通过负载均衡技术(智能DNS)，将用户的请求定向到最合适的缓存服务器上，以此来提高用户访问网络的响应速度，解决网络拥堵情况。



使用方法：

一般配一个缓存服务器的cname

然后用户发起请求的时候 通过智能 dns 解析(根据位置网络类型，就近选择)获取缓存服务器的地址，然后请求缓存服务器，如果此时缓存服务器里面有相关的内容直接返回，如果没有就直接向源站发起请求然后返回并且缓存内容



使用场景：多媒体内容、图片、视频、直播流







![2022010503](/Users/wfy/Documents/KnowledgeBase/picture/network/2022010503.jpg)



**到底什么是中间人攻击？如何避免**

当数据传输发生在一个设备（PC/手机）和网络服务器之间时，攻击者使用其技能和工具将自己置于两个端点之间并截获数据；尽管交谈的两方认为他们是在与对方交谈，但是实际上他们是在与干坏事的人交流，这便是中间人攻击。

总而言之，这是一个诈骗伎俩。



避免使用不安全的网络（机场or 外面的免费wifi）

使用安全软件

一般在网络协议中 使用HTTPs （例外，抓包没办法管昂，自己愿意的）



**为什么需要序列化？有什么序列化的方式？**

**我们要把数据，保存在存储组件或者在网络传输时候，需要将内存中的对象用文本的格式表示，**

**常见的应用层序列化协议， proto buf ，json , java hession 等**



**TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？**

https://mp.weixin.qq.com/s/2qN0ulyBtO2I67NB_RnJbg

1.time_wait 

场景：在高并发短连接的TCP服务器上可能出现

应用层优化方法：尽量避免频繁关闭连接，如业务优化，或者使用长连接等

调整内核参数，缩短time_wait 的时间

包括开启 链接重用 和 缩短异常情况 final_wait_2 转移到 time_wait 时间



2.close_wait  

处于客户端关闭，等待服务端主动关闭

一般是应用层，没主动关闭http 链接导致的。例如（mysql 没提交 or 回滚 ）需要具体业务具体分析。都是自己的bug





**简述 RPC 的调用过程**

序列化，开启tcp 链接，传输，反序列化，交给应用层



**简述 OSI 七层模型，TCP，IP 属于哪一层？**

物理，数据链路、网络、运输层，会话层，表示层、应用层  

tcp 属于具体端到端的协议，在运输层，ip 属于网络层是网络层协议，是能找到具体的网络设备



**什么是 TCP 粘包和拆包？**

粘包就是收到的数据无法分辨具体应用层协议的界限，导致解析不正确

，拆包就是将收到的数据 根据界限协议将数据分开的过程



粘包原因：

1. tcp 一次将多个数据包发送出去
2. 或者发送缓冲区太小出现积压
3. 或者接收端来不急处理



核心问题就是没有协议区分消息边界



如何解决，（如何正确拆包）

以HTTP 协议为例子就行了 

1.通过 \r\n 区分header、content ，在header 里通过 content-longth 区分消息边界 

2.通过特殊字符区分消息边界， —ljflasjiogjaogjf—— , 或者\r\n



**什么是跨域，什么情况下会发生跨域请求？**

就是本网站的 js 请求其他网站的资源，然后被浏览器拦截。 核心是数据请求可以，但是浏览器不给用。



如何解决：

1.NGINX 代理跨域：外站通过 header 配置 1.允许 跨域的域名，2.执行可跨域的 方法，3.可传递的header 等。

请求方法：

1. 浏览器先 发起 head 方法请求，通知服务器，服务器回 100 允许
2. 正常请求就可以了



其他：jsonp 啥的，项目里面没用过





**TCP 怎么保证可靠传输？**

理论基础：
 停止等待协议， 没法送一个等待确认，超时重传， 接收端，收到后回复ack ，收到重复的丢弃然后还要回复ack 。

前提：1，发送端，接收端缓存，2. 必须有序号，代表那些包是正确有序的 3.每个包都要有超时重传计时器



**从输入 URL 到展现页面的全过程** 

dns ?

然后https?

。。。。。。。 太磨叽了







**HTTP 常见的 header 都有啥**

请求:

accept 代表发送端（客户端）希望接受的数据类型

Accept-charser

Accept-encoding 可接受的内容编码方式 通常是某种压缩算法

Cookie 

Content-length



Host

Origin

Range

User-agent



响应：

**Content-Type** 实体头部用于指示资源的MIME类型 [media type](https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type) 。

**Content-Encoding** 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容。

**Expires** 响应头包含日期/时间， 即在此时候之后，响应过期。

 **Cache-Control** 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。 例子：Cache-Control: max-age=<seconds>



Content-language

Location

Date

Set-cookie

Transfer-encoding

Upgrade





**Content-type 内容是啥**

text/html; charset=utf-8







使用默认的 application/x-www-form-urlencoded 做为 content type 的简单表单:

POST / HTTP/1.1

Host: foo.com

Content-Type: application/x-www-form-urlencoded

Content-Length: 13



say=Hi&to=Mom



使用 multipart/form-data 作为 content type 的表单:

POST /test.html HTTP/1.1

Host: example.org

Content-Type: multipart/form-data;boundary="boundary"



--boundary

Content-Disposition: form-data; name="field1"



value1

--boundary

Content-Disposition: form-data; name="field2"; filename="example.txt"



value2